<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Image view and sampler - Vulkan Tutorial</title>
    <meta name="description" content="A tutorial that teaches you everything it takes to render 3D graphics with the Vulkan API. It covers everything from Windows/Linux setup to rendering and debugging." />
    <meta name="author" content="Alexander Overvoorde">
    <meta charset="UTF-8">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    
    <!-- CSS -->
    <link href='../../themes/vulkan/css/theme.min.css' rel='stylesheet' type='text/css'><link href='../../themes/vulkan/css/theme-blue.min.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<div class="container-fluid fluid-height wrapper">
    <div class="row columns content">
        <div class="left-column article-tree col-sm-3 hidden-print">
            <!-- For Mobile -->
            <div class="responsive-collapse">
                <button type="button" class="btn btn-sidebar" id="menu-spinner-button">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div id="sub-nav-collapse" class="sub-nav-collapse">
                <div class="nav-logo">
                    Vulkan Tutorial
                </div>

                <!-- Language picker -->
                <div class="language-picker">
                <a href="/Introduction">English</a>                </div>

                <!-- Navigation -->
                <div style="padding-top: 20px; padding-bottom: 20px; background: #272525">
                <ul class='Nav'><li class='Nav__item '><a href="../../en/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../en/Overview.html">Overview</a></li><li class='Nav__item '><a href="../../en/Development_environment.html">Development environment</a></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing a triangle</a><ul class='Nav'><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Setup</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Base_code.html">Base code</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Instance.html">Instance</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Validation_layers.html">Validation layers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families.html">Physical devices and queue families</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Logical device and queues</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Presentation/Window_surface.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Presentation</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Window_surface.html">Window surface</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Swap_chain.html">Swap chain</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Image_views.html">Image views</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Graphics pipeline basics</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules.html">Shader modules</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions.html">Fixed functions</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes.html">Render passes</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion.html">Conclusion</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Drawing/Framebuffers.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Framebuffers.html">Framebuffers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Command_buffers.html">Command buffers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Rendering_and_presentation.html">Rendering and presentation</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Frames_in_flight.html">Frames in flight</a></li></ul></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Swap_chain_recreation.html">Swap chain recreation</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Vertex_buffers/Vertex_input_description.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Vertex buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Vertex_buffers/Vertex_input_description.html">Vertex input description</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Vertex_buffer_creation.html">Vertex buffer creation</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Staging_buffer.html">Staging buffer</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Index_buffer.html">Index buffer</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Uniform buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Descriptor set layout and buffer</a></li><li class='Nav__item '><a href="../../en/Uniform_buffers/Descriptor_pool_and_sets.html">Descriptor pool and sets</a></li></ul></li><li class='Nav__item Nav__item--open has-children'><a href="../../en/Texture_mapping/Images.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Texture mapping</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Texture_mapping/Images.html">Images</a></li><li class='Nav__item Nav__item--active'><a href="../../en/Texture_mapping/Image_view_and_sampler.html">Image view and sampler</a></li><li class='Nav__item '><a href="../../en/Texture_mapping/Combined_image_sampler.html">Combined image sampler</a></li></ul></li><li class='Nav__item '><a href="../../en/Depth_buffering.html">Depth buffering</a></li><li class='Nav__item '><a href="../../en/Loading_models.html">Loading models</a></li><li class='Nav__item '><a href="../../en/Generating_Mipmaps.html">Generating Mipmaps</a></li><li class='Nav__item '><a href="../../en/Multisampling.html">Multisampling</a></li><li class='Nav__item '><a href="../../en/Compute_Shader.html">Compute Shader</a></li><li class='Nav__item '><a href="../../en/FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../../en/Privacy_policy.html">Privacy policy</a></li></ul>                </div>

                <div class="sidebar-links">
                    
                        <!-- Links -->
                        <a href="https://github.com/Overv/VulkanTutorial" target="_blank">GitHub Repository</a><br><a href="https://www.paypal.me/AOvervoorde" target="_blank">Support the website</a><br><br><a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/" target="_blank">Vulkan Specification</a><br><a href="https://lunarg.com/vulkan-sdk/" target="_blank">LunarG Vulkan SDK</a><br><a href="https://github.com/KhronosGroup/Vulkan-Guide" target="_blank">Vulkan Guide</a><br><a href="https://vulkan.gpuinfo.org/" target="_blank">Vulkan Hardware Database</a><br><br><a href="https://github.com/bwasty/vulkan-tutorial-rs" target="_blank">Rust code</a><br><a href="https://github.com/Naitsirc98/Vulkan-Tutorial-Java" target="_blank">Java code</a><br><a href="https://github.com/vkngwrapper/vulkan-tutorial" target="_blank">Go code</a><br><a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles" target="_blank">Visual Studio 2019 samples</a><br><a href="https://github.com/fangcun010/VulkanTutorialCN" target="_blank">Chinese translation</a><br>
                        <div id="toggleCodeBlock">
                                                </div>

                        <!-- Twitter -->
                                                            </div>

                <div style="color: #666; padding: 0 20px 0 20px; font-size: 90%">
                    This site is not affiliated with or endorsed by the Khronos Group. VulkanÂ® and the Vulkan logo are trademarks of the Khronos Group Inc.
                </div>
            </div>
        </div>
        <div class="right-column  content-area col-sm-9">
            <div class="content-page" style="position: relative;">
                <div class="adbox-side" style="position: absolute; left: calc(100% + 50px);">
                    <div id="waldo-tag-4310"></div>
                </div>

                <div class="adbox-side" style="position: absolute; left: -350px">
                    <div id="waldo-tag-4312"></div>
                </div>

                                    <div id="tipue_search_content" style="display:none"></div>
                
                <div class="doc_content">
                    <article>
            <div class="page-header">
            <h1>Image view and sampler</h1>
        </div>
    
    <ul class="TableOfContents">
<li>
<p><a href="#page_Texture-image-view">Texture image view</a></p>
</li>
<li>
<p><a href="#page_Samplers">Samplers</a></p>
</li>
<li>
<p><a href="#page_Anisotropy-device-feature">Anisotropy device feature</a></p>
</li>
</ul>
<p>In this chapter we're going to create two more resources that are needed for the
graphics pipeline to sample an image. The first resource is one that we've
already seen before while working with the swap chain images, but the second one
is new - it relates to how the shader will read texels from the image.</p>
<h2 id="page_Texture-image-view">Texture image view</h2>
<p>We've seen before, with the swap chain images and the framebuffer, that images
are accessed through image views rather than directly. We will also need to
create such an image view for the texture image.</p>
<p>Add a class member to hold a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkImageView.html"><code>VkImageView</code></a> for the texture image and create a
new function <code>createTextureImageView</code> where we'll create it:</p>
<pre><code class="language-c++">VkImageView textureImageView;

...

void initVulkan() {
    ...
    createTextureImage();
    createTextureImageView();
    createVertexBuffer();
    ...
}

...

void createTextureImageView() {

}
</code></pre>
<p>The code for this function can be based directly on <code>createImageViews</code>. The only
two changes you have to make are the <code>format</code> and the <code>image</code>:</p>
<pre><code class="language-c++">VkImageViewCreateInfo viewInfo{};
viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
viewInfo.image = textureImage;
viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
viewInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
viewInfo.subresourceRange.baseMipLevel = 0;
viewInfo.subresourceRange.levelCount = 1;
viewInfo.subresourceRange.baseArrayLayer = 0;
viewInfo.subresourceRange.layerCount = 1;
</code></pre>
<p>I've left out the explicit <code>viewInfo.components</code> initialization, because
<code>VK_COMPONENT_SWIZZLE_IDENTITY</code> is defined as <code>0</code> anyway. Finish creating the
image view by calling <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateImageView.html"><code>vkCreateImageView</code></a>:</p>
<pre><code class="language-c++">if (vkCreateImageView(device, &amp;viewInfo, nullptr, &amp;textureImageView) != VK_SUCCESS) {
    throw std::runtime_error(&quot;failed to create texture image view!&quot;);
}
</code></pre>
<p>Because so much of the logic is duplicated from <code>createImageViews</code>, you may wish
to abstract it into a new <code>createImageView</code> function:</p>
<pre><code class="language-c++">VkImageView createImageView(VkImage image, VkFormat format) {
    VkImageViewCreateInfo viewInfo{};
    viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
    viewInfo.image = image;
    viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
    viewInfo.format = format;
    viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    viewInfo.subresourceRange.baseMipLevel = 0;
    viewInfo.subresourceRange.levelCount = 1;
    viewInfo.subresourceRange.baseArrayLayer = 0;
    viewInfo.subresourceRange.layerCount = 1;

    VkImageView imageView;
    if (vkCreateImageView(device, &amp;viewInfo, nullptr, &amp;imageView) != VK_SUCCESS) {
        throw std::runtime_error(&quot;failed to create image view!&quot;);
    }

    return imageView;
}
</code></pre>
<p>The <code>createTextureImageView</code> function can now be simplified to:</p>
<pre><code class="language-c++">void createTextureImageView() {
    textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_SRGB);
}
</code></pre>
<p>And <code>createImageViews</code> can be simplified to:</p>
<pre><code class="language-c++">void createImageViews() {
    swapChainImageViews.resize(swapChainImages.size());

    for (uint32_t i = 0; i &lt; swapChainImages.size(); i++) {
        swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat);
    }
}
</code></pre>
<p>Make sure to destroy the image view at the end of the program, right before
destroying the image itself:</p>
<pre><code class="language-c++">void cleanup() {
    cleanupSwapChain();

    vkDestroyImageView(device, textureImageView, nullptr);

    vkDestroyImage(device, textureImage, nullptr);
    vkFreeMemory(device, textureImageMemory, nullptr);
</code></pre>
<h2 id="page_Samplers">Samplers</h2>
<p>It is possible for shaders to read texels directly from images, but that is not
very common when they are used as textures. Textures are usually accessed
through samplers, which will apply filtering and transformations to compute the
final color that is retrieved.</p>
<p>These filters are helpful to deal with problems like oversampling. Consider a
texture that is mapped to geometry with more fragments than texels. If you
simply took the closest texel for the texture coordinate in each fragment, then
you would get a result like the first image:</p>
<p><img src="/images/texture_filtering.png" alt="" /></p>
<p>If you combined the 4 closest texels through linear interpolation, then you
would get a smoother result like the one on the right. Of course your
application may have art style requirements that fit the left style more (think
Minecraft), but the right is preferred in conventional graphics applications. A
sampler object automatically applies this filtering for you when reading a color
from the texture.</p>
<p>Undersampling is the opposite problem, where you have more texels than
fragments. This will lead to artifacts when sampling high frequency patterns
like a checkerboard texture at a sharp angle:</p>
<p><img src="/images/anisotropic_filtering.png" alt="" /></p>
<p>As shown in the left image, the texture turns into a blurry mess in the
distance. The solution to this is <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering" class="Link--external">anisotropic filtering</a>,
which can also be applied automatically by a sampler.</p>
<p>Aside from these filters, a sampler can also take care of transformations. It
determines what happens when you try to read texels outside the image through
its <em>addressing mode</em>. The image below displays some of the possibilities:</p>
<p><img src="/images/texture_addressing.png" alt="" /></p>
<p>We will now create a function <code>createTextureSampler</code> to set up such a sampler
object. We'll be using that sampler to read colors from the texture in the
shader later on.</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    createTextureImage();
    createTextureImageView();
    createTextureSampler();
    ...
}

...

void createTextureSampler() {

}
</code></pre>
<p>Samplers are configured through a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkSamplerCreateInfo.html"><code>VkSamplerCreateInfo</code></a> structure, which
specifies all filters and transformations that it should apply.</p>
<pre><code class="language-c++">VkSamplerCreateInfo samplerInfo{};
samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
samplerInfo.magFilter = VK_FILTER_LINEAR;
samplerInfo.minFilter = VK_FILTER_LINEAR;
</code></pre>
<p>The <code>magFilter</code> and <code>minFilter</code> fields specify how to interpolate texels that
are magnified or minified. Magnification concerns the oversampling problem
describes above, and minification concerns undersampling. The choices are
<code>VK_FILTER_NEAREST</code> and <code>VK_FILTER_LINEAR</code>, corresponding to the modes
demonstrated in the images above.</p>
<pre><code class="language-c++">samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;
samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;
samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT;
</code></pre>
<p>The addressing mode can be specified per axis using the <code>addressMode</code> fields.
The available values are listed below. Most of these are demonstrated in the
image above. Note that the axes are called U, V and W instead of X, Y and Z.
This is a convention for texture space coordinates.</p>
<ul>
<li>
<code>VK_SAMPLER_ADDRESS_MODE_REPEAT</code>: Repeat the texture when going beyond the
image dimensions.</li>
<li>
<code>VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT</code>: Like repeat, but inverts the
coordinates to mirror the image when going beyond the dimensions.</li>
<li>
<code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE</code>: Take the color of the edge closest to
the coordinate beyond the image dimensions.</li>
<li>
<code>VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE</code>: Like clamp to edge, but
instead uses the edge opposite to the closest edge.</li>
<li>
<code>VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER</code>: Return a solid color when sampling
beyond the dimensions of the image.</li>
</ul>
<p>It doesn't really matter which addressing mode we use here, because we're not
going to sample outside of the image in this tutorial. However, the repeat mode
is probably the most common mode, because it can be used to tile textures like
floors and walls.</p>
<pre><code class="language-c++">samplerInfo.anisotropyEnable = VK_TRUE;
samplerInfo.maxAnisotropy = ???;
</code></pre>
<p>These two fields specify if anisotropic filtering should be used. There is no
reason not to use this unless performance is a concern. The <code>maxAnisotropy</code>
field limits the amount of texel samples that can be used to calculate the final
color. A lower value results in better performance, but lower quality results.
To figure out which value we can use, we need to retrieve the properties of the physical device like so:</p>
<pre><code class="language-c++">VkPhysicalDeviceProperties properties{};
vkGetPhysicalDeviceProperties(physicalDevice, &amp;properties);
</code></pre>
<p>If you look at the documentation for the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDeviceProperties.html"><code>VkPhysicalDeviceProperties</code></a> structure, you'll see that it contains a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDeviceLimits.html"><code>VkPhysicalDeviceLimits</code></a> member named <code>limits</code>. This struct in turn has a member called <code>maxSamplerAnisotropy</code> and this is the maximum value we can specify for <code>maxAnisotropy</code>. If we want to go for maximum quality, we can simply use that value directly:</p>
<pre><code class="language-c++">samplerInfo.maxAnisotropy = properties.limits.maxSamplerAnisotropy;
</code></pre>
<p>You can either query the properties at the beginning of your program and pass them around to the functions that need them, or query them in the <code>createTextureSampler</code> function itself.</p>
<pre><code class="language-c++">samplerInfo.borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK;
</code></pre>
<p>The <code>borderColor</code> field specifies which color is returned when sampling beyond
the image with clamp to border addressing mode. It is possible to return black,
white or transparent in either float or int formats. You cannot specify an
arbitrary color.</p>
<pre><code class="language-c++">samplerInfo.unnormalizedCoordinates = VK_FALSE;
</code></pre>
<p>The <code>unnormalizedCoordinates</code> field specifies which coordinate system you want
to use to address texels in an image. If this field is <code>VK_TRUE</code>, then you can
simply use coordinates within the <code>[0, texWidth)</code> and <code>[0, texHeight)</code> range. If
it is <code>VK_FALSE</code>, then the texels are addressed using the <code>[0, 1)</code> range on all
axes. Real-world applications almost always use normalized coordinates, because
then it's possible to use textures of varying resolutions with the exact same
coordinates.</p>
<pre><code class="language-c++">samplerInfo.compareEnable = VK_FALSE;
samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS;
</code></pre>
<p>If a comparison function is enabled, then texels will first be compared to a
value, and the result of that comparison is used in filtering operations. This
is mainly used for <a href="https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html" class="Link--external">percentage-closer filtering</a>
on shadow maps. We'll look at this in a future chapter.</p>
<pre><code class="language-c++">samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;
samplerInfo.mipLodBias = 0.0f;
samplerInfo.minLod = 0.0f;
samplerInfo.maxLod = 0.0f;
</code></pre>
<p>All of these fields apply to mipmapping. We will look at mipmapping in a <a href="../Generating_Mipmaps.html">later
chapter</a>, but basically it's another type of filter that can be applied.</p>
<p>The functioning of the sampler is now fully defined. Add a class member to
hold the handle of the sampler object and create the sampler with
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateSampler.html"><code>vkCreateSampler</code></a>:</p>
<pre><code class="language-c++">VkImageView textureImageView;
VkSampler textureSampler;

...

void createTextureSampler() {
    ...

    if (vkCreateSampler(device, &amp;samplerInfo, nullptr, &amp;textureSampler) != VK_SUCCESS) {
        throw std::runtime_error(&quot;failed to create texture sampler!&quot;);
    }
}
</code></pre>
<p>Note the sampler does not reference a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkImage.html"><code>VkImage</code></a> anywhere. The sampler is a
distinct object that provides an interface to extract colors from a texture. It
can be applied to any image you want, whether it is 1D, 2D or 3D. This is
different from many older APIs, which combined texture images and filtering into
a single state.</p>
<p>Destroy the sampler at the end of the program when we'll no longer be accessing
the image:</p>
<pre><code class="language-c++">void cleanup() {
    cleanupSwapChain();

    vkDestroySampler(device, textureSampler, nullptr);
    vkDestroyImageView(device, textureImageView, nullptr);

    ...
}
</code></pre>
<h2 id="page_Anisotropy-device-feature">Anisotropy device feature</h2>
<p>If you run your program right now, you'll see a validation layer message like
this:</p>
<p><img src="/images/validation_layer_anisotropy.png" alt="" /></p>
<p>That's because anisotropic filtering is actually an optional device feature. We
need to update the <code>createLogicalDevice</code> function to request it:</p>
<pre><code class="language-c++">VkPhysicalDeviceFeatures deviceFeatures{};
deviceFeatures.samplerAnisotropy = VK_TRUE;
</code></pre>
<p>And even though it is very unlikely that a modern graphics card will not support
it, we should update <code>isDeviceSuitable</code> to check if it is available:</p>
<pre><code class="language-c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    ...

    VkPhysicalDeviceFeatures supportedFeatures;
    vkGetPhysicalDeviceFeatures(device, &amp;supportedFeatures);

    return indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;
}
</code></pre>
<p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a> repurposes the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDeviceFeatures.html"><code>VkPhysicalDeviceFeatures</code></a>
struct to indicate which features are supported rather than requested by setting
the boolean values.</p>
<p>Instead of enforcing the availability of anisotropic filtering, it's also
possible to simply not use it by conditionally setting:</p>
<pre><code class="language-c++">samplerInfo.anisotropyEnable = VK_FALSE;
samplerInfo.maxAnisotropy = 1.0f;
</code></pre>
<p>In the next chapter we will expose the image and sampler objects to the shaders
to draw the texture onto the square.</p>
<p><a href="../../code/25_sampler.cpp">C++ code</a> /
<a href="../../code/22_shader_ubo.vert">Vertex shader</a> /
<a href="../../code/22_shader_ubo.frag">Fragment shader</a></p>

        <nav>
        <ul class="pager">
            <li><a href="../../en/Texture_mapping/Images.html">Previous</a></li>            <li><a href="../../en/Texture_mapping/Combined_image_sampler.html">Next</a></li>        </ul>
    </nav>
    
        <div id="waldo-tag-4314"></div>
    
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </article>

                </div>
            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../../themes/vulkan/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../../themes/vulkan/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../../themes/vulkan/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../../tipuesearch/tipuesearch_set.js"></script>
        <script type="text/javascript" src="../../tipuesearch/tipuesearch.min.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(document).ready(function() {
                $('#tipue_search_input').tipuesearch({
                    'show': 10,
                    'mode': 'json',
                    'base_url': '../../'
                });
            });
        </script>
    
</body>
</html>
