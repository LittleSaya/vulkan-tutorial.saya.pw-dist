<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Physical devices and queue families - Vulkan Tutorial</title>
    <meta name="description" content="A tutorial that teaches you everything it takes to render 3D graphics with the Vulkan API. It covers everything from Windows/Linux setup to rendering and debugging." />
    <meta name="author" content="Alexander Overvoorde">
    <meta charset="UTF-8">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    
    <!-- CSS -->
    <link href='../../../themes/vulkan/css/theme.min.css' rel='stylesheet' type='text/css'><link href='../../../themes/vulkan/css/theme-blue.min.css' rel='stylesheet' type='text/css'><link href='../../../themes/vulkan/css/css.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../../../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<div class="container-fluid fluid-height wrapper">
    <div class="row columns content">
        <div class="left-column article-tree col-sm-3 hidden-print">
            <!-- For Mobile -->
            <div class="responsive-collapse">
                <button type="button" class="btn btn-sidebar" id="menu-spinner-button">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div id="sub-nav-collapse" class="sub-nav-collapse">
                <div class="nav-logo">
                    Vulkan Tutorial
                </div>

                <!-- Language picker -->
                <div class="language-picker">
                <a href="/Introduction">English</a>                </div>

                <!-- Navigation -->
                <div style="padding-top: 20px; padding-bottom: 20px; background: #272525">
                <ul class='Nav'><li class='Nav__item '><a href="../../../en/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../../en/Overview.html">Overview</a></li><li class='Nav__item '><a href="../../../en/Development_environment.html">Development environment</a></li><li class='Nav__item Nav__item--open has-children'><a href="../../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing a triangle</a><ul class='Nav'><li class='Nav__item Nav__item--open has-children'><a href="../../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Setup</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Setup/Base_code.html">Base code</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Setup/Instance.html">Instance</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Setup/Validation_layers.html">Validation layers</a></li><li class='Nav__item Nav__item--active'><a href="../../../en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families.html">Physical devices and queue families</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Logical device and queues</a></li></ul></li><li class='Nav__item  has-children'><a href="../../../en/Drawing_a_triangle/Presentation/Window_surface.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Presentation</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Presentation/Window_surface.html">Window surface</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Presentation/Swap_chain.html">Swap chain</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Presentation/Image_views.html">Image views</a></li></ul></li><li class='Nav__item  has-children'><a href="../../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Graphics pipeline basics</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules.html">Shader modules</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions.html">Fixed functions</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes.html">Render passes</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion.html">Conclusion</a></li></ul></li><li class='Nav__item  has-children'><a href="../../../en/Drawing_a_triangle/Drawing/Framebuffers.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Drawing/Framebuffers.html">Framebuffers</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Drawing/Command_buffers.html">Command buffers</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Drawing/Rendering_and_presentation.html">Rendering and presentation</a></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Drawing/Frames_in_flight.html">Frames in flight</a></li></ul></li><li class='Nav__item '><a href="../../../en/Drawing_a_triangle/Swap_chain_recreation.html">Swap chain recreation</a></li></ul></li><li class='Nav__item  has-children'><a href="../../../en/Vertex_buffers/Vertex_input_description.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Vertex buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Vertex_buffers/Vertex_input_description.html">Vertex input description</a></li><li class='Nav__item '><a href="../../../en/Vertex_buffers/Vertex_buffer_creation.html">Vertex buffer creation</a></li><li class='Nav__item '><a href="../../../en/Vertex_buffers/Staging_buffer.html">Staging buffer</a></li><li class='Nav__item '><a href="../../../en/Vertex_buffers/Index_buffer.html">Index buffer</a></li></ul></li><li class='Nav__item  has-children'><a href="../../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Uniform buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Descriptor set layout and buffer</a></li><li class='Nav__item '><a href="../../../en/Uniform_buffers/Descriptor_pool_and_sets.html">Descriptor pool and sets</a></li></ul></li><li class='Nav__item  has-children'><a href="../../../en/Texture_mapping/Images.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Texture mapping</a><ul class='Nav'><li class='Nav__item '><a href="../../../en/Texture_mapping/Images.html">Images</a></li><li class='Nav__item '><a href="../../../en/Texture_mapping/Image_view_and_sampler.html">Image view and sampler</a></li><li class='Nav__item '><a href="../../../en/Texture_mapping/Combined_image_sampler.html">Combined image sampler</a></li></ul></li><li class='Nav__item '><a href="../../../en/Depth_buffering.html">Depth buffering</a></li><li class='Nav__item '><a href="../../../en/Loading_models.html">Loading models</a></li><li class='Nav__item '><a href="../../../en/Generating_Mipmaps.html">Generating Mipmaps</a></li><li class='Nav__item '><a href="../../../en/Multisampling.html">Multisampling</a></li><li class='Nav__item '><a href="../../../en/Compute_Shader.html">Compute Shader</a></li><li class='Nav__item '><a href="../../../en/FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../../../en/Privacy_policy.html">Privacy policy</a></li></ul>                </div>

                <div class="sidebar-links">
                    
                        <!-- Links -->
                        <a href="https://github.com/Overv/VulkanTutorial" target="_blank">GitHub Repository</a><br><a href="https://www.paypal.me/AOvervoorde" target="_blank">Support the website</a><br><br><a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/" target="_blank">Vulkan Specification</a><br><a href="https://lunarg.com/vulkan-sdk/" target="_blank">LunarG Vulkan SDK</a><br><a href="https://github.com/KhronosGroup/Vulkan-Guide" target="_blank">Vulkan Guide</a><br><a href="https://vulkan.gpuinfo.org/" target="_blank">Vulkan Hardware Database</a><br><br><a href="https://github.com/bwasty/vulkan-tutorial-rs" target="_blank">Rust code</a><br><a href="https://github.com/Naitsirc98/Vulkan-Tutorial-Java" target="_blank">Java code</a><br><a href="https://github.com/vkngwrapper/vulkan-tutorial" target="_blank">Go code</a><br><a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles" target="_blank">Visual Studio 2019 samples</a><br><a href="https://github.com/fangcun010/VulkanTutorialCN" target="_blank">Chinese translation</a><br>
                        <div id="toggleCodeBlock">
                                                </div>

                        <!-- Twitter -->
                                                            </div>

                <div style="color: #666; padding: 0 20px 0 20px; font-size: 90%">
                    This site is not affiliated with or endorsed by the Khronos Group. VulkanÂ® and the Vulkan logo are trademarks of the Khronos Group Inc.
                </div>
            </div>
        </div>
        <div class="right-column  content-area col-sm-9">
            <div class="content-page" style="position: relative;">
                <div class="adbox-side" style="position: absolute; left: calc(100% + 50px);">
                    <div id="waldo-tag-4310"></div>
                </div>

                <div class="adbox-side" style="position: absolute; left: -350px">
                    <div id="waldo-tag-4312"></div>
                </div>

                                    <div id="tipue_search_content" style="display:none"></div>
                
                <div class="doc_content">
                    <article>
            <div class="page-header">
            <h1>Physical devices and queue families</h1>
        </div>
    
    <ul class="TableOfContents">
<li>
<p><a href="#page_Selecting-a-physical-device">Selecting a physical device</a></p>
</li>
<li>
<p><a href="#page_Base-device-suitability-checks">Base device suitability checks</a></p>
</li>
<li>
<p><a href="#page_Queue-families">Queue families</a></p>
</li>
</ul>
<h2 id="page_Selecting-a-physical-device">Selecting a physical device</h2>
<p>After initializing the Vulkan library through a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstance.html"><code>VkInstance</code></a> we need to look for
and select a graphics card in the system that supports the features we need. In
fact we can select any number of graphics cards and use them simultaneously, but
in this tutorial we'll stick to the first graphics card that suits our needs.</p>
<p>We'll add a function <code>pickPhysicalDevice</code> and add a call to it in the
<code>initVulkan</code> function.</p>
<pre><code class="language-c++">void initVulkan() {
    createInstance();
    setupDebugMessenger();
    pickPhysicalDevice();
}

void pickPhysicalDevice() {

}
</code></pre>
<p>The graphics card that we'll end up selecting will be stored in a
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a> handle that is added as a new class member. This object will be
implicitly destroyed when the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkInstance.html"><code>VkInstance</code></a> is destroyed, so we won't need to do
anything new in the <code>cleanup</code> function.</p>
<pre><code class="language-c++">VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
</code></pre>
<p>Listing the graphics cards is very similar to listing extensions and starts with
querying just the number.</p>
<pre><code class="language-c++">uint32_t deviceCount = 0;
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr);
</code></pre>
<p>If there are 0 devices with Vulkan support then there is no point going further.</p>
<pre><code class="language-c++">if (deviceCount == 0) {
    throw std::runtime_error(&quot;failed to find GPUs with Vulkan support!&quot;);
}
</code></pre>
<p>Otherwise we can now allocate an array to hold all of the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPhysicalDevice.html"><code>VkPhysicalDevice</code></a>
handles.</p>
<pre><code class="language-c++">std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);
vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data());
</code></pre>
<p>Now we need to evaluate each of them and check if they are suitable for the
operations we want to perform, because not all graphics cards are created equal.
For that we'll introduce a new function:</p>
<pre><code class="language-c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    return true;
}
</code></pre>
<p>And we'll check if any of the physical devices meet the requirements that we'll
add to that function.</p>
<pre><code class="language-c++">for (const auto&amp; device : devices) {
    if (isDeviceSuitable(device)) {
        physicalDevice = device;
        break;
    }
}

if (physicalDevice == VK_NULL_HANDLE) {
    throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);
}
</code></pre>
<p>The next section will introduce the first requirements that we'll check for in
the <code>isDeviceSuitable</code> function. As we'll start using more Vulkan features in
the later chapters we will also extend this function to include more checks.</p>
<h2 id="page_Base-device-suitability-checks">Base device suitability checks</h2>
<p>To evaluate the suitability of a device we can start by querying for some
details. Basic device properties like the name, type and supported Vulkan
version can be queried using <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetPhysicalDeviceProperties.html"><code>vkGetPhysicalDeviceProperties</code></a>.</p>
<pre><code class="language-c++">VkPhysicalDeviceProperties deviceProperties;
vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
</code></pre>
<p>The support for optional features like texture compression, 64 bit floats and
multi viewport rendering (useful for VR) can be queried using
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetPhysicalDeviceFeatures.html"><code>vkGetPhysicalDeviceFeatures</code></a>:</p>
<pre><code class="language-c++">VkPhysicalDeviceFeatures deviceFeatures;
vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);
</code></pre>
<p>There are more details that can be queried from devices that we'll discuss later
concerning device memory and queue families (see the next section).</p>
<p>As an example, let's say we consider our application only usable for dedicated
graphics cards that support geometry shaders. Then the <code>isDeviceSuitable</code>
function would look like this:</p>
<pre><code class="language-c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    VkPhysicalDeviceProperties deviceProperties;
    VkPhysicalDeviceFeatures deviceFeatures;
    vkGetPhysicalDeviceProperties(device, &amp;deviceProperties);
    vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures);

    return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &amp;&amp;
           deviceFeatures.geometryShader;
}
</code></pre>
<p>Instead of just checking if a device is suitable or not and going with the first
one, you could also give each device a score and pick the highest one. That way
you could favor a dedicated graphics card by giving it a higher score, but fall
back to an integrated GPU if that's the only available one. You could implement
something like that as follows:</p>
<pre><code class="language-c++">#include &lt;map&gt;

...

void pickPhysicalDevice() {
    ...

    // Use an ordered map to automatically sort candidates by increasing score
    std::multimap&lt;int, VkPhysicalDevice&gt; candidates;

    for (const auto&amp; device : devices) {
        int score = rateDeviceSuitability(device);
        candidates.insert(std::make_pair(score, device));
    }

    // Check if the best candidate is suitable at all
    if (candidates.rbegin()-&gt;first &gt; 0) {
        physicalDevice = candidates.rbegin()-&gt;second;
    } else {
        throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);
    }
}

int rateDeviceSuitability(VkPhysicalDevice device) {
    ...

    int score = 0;

    // Discrete GPUs have a significant performance advantage
    if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) {
        score += 1000;
    }

    // Maximum possible size of textures affects graphics quality
    score += deviceProperties.limits.maxImageDimension2D;

    // Application can't function without geometry shaders
    if (!deviceFeatures.geometryShader) {
        return 0;
    }

    return score;
}
</code></pre>
<p>You don't need to implement all that for this tutorial, but it's to give you an
idea of how you could design your device selection process. Of course you can
also just display the names of the choices and allow the user to select.</p>
<p>Because we're just starting out, Vulkan support is the only thing we need and
therefore we'll settle for just any GPU:</p>
<pre><code class="language-c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    return true;
}
</code></pre>
<p>In the next section we'll discuss the first real required feature to check for.</p>
<h2 id="page_Queue-families">Queue families</h2>
<p>It has been briefly touched upon before that almost every operation in Vulkan,
anything from drawing to uploading textures, requires commands to be submitted
to a queue. There are different types of queues that originate from different
<em>queue families</em> and each family of queues allows only a subset of commands. For
example, there could be a queue family that only allows processing of compute
commands or one that only allows memory transfer related commands.</p>
<p>We need to check which queue families are supported by the device and which one
of these supports the commands that we want to use. For that purpose we'll add a
new function <code>findQueueFamilies</code> that looks for all the queue families we need.</p>
<p>Right now we are only going to look for a queue that supports graphics commands,
so the function could look like this:</p>
<pre><code class="language-c++">uint32_t findQueueFamilies(VkPhysicalDevice device) {
    // Logic to find graphics queue family
}
</code></pre>
<p>However, in one of the next chapters we're already going to look for yet another
queue, so it's better to prepare for that and bundle the indices into a struct:</p>
<pre><code class="language-c++">struct QueueFamilyIndices {
    uint32_t graphicsFamily;
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    // Logic to find queue family indices to populate struct with
    return indices;
}
</code></pre>
<p>But what if a queue family is not available? We could throw an exception in
<code>findQueueFamilies</code>, but this function is not really the right place to make
decisions about device suitability. For example, we may <em>prefer</em> devices with a
dedicated transfer queue family, but not require it. Therefore we need some way
of indicating whether a particular queue family was found.</p>
<p>It's not really possible to use a magic value to indicate the nonexistence of a
queue family, since any value of <code>uint32_t</code> could in theory be a valid queue
family index including <code>0</code>. Luckily C++17 introduced a data structure to
distinguish between the case of a value existing or not:</p>
<pre><code class="language-c++">#include &lt;optional&gt;

...

std::optional&lt;uint32_t&gt; graphicsFamily;

std::cout &lt;&lt; std::boolalpha &lt;&lt; graphicsFamily.has_value() &lt;&lt; std::endl; // false

graphicsFamily = 0;

std::cout &lt;&lt; std::boolalpha &lt;&lt; graphicsFamily.has_value() &lt;&lt; std::endl; // true
</code></pre>
<p><code>std::optional</code> is a wrapper that contains no value until you assign something
to it. At any point you can query if it contains a value or not by calling its
<code>has_value()</code> member function. That means that we can change the logic to:</p>
<pre><code class="language-c++">#include &lt;optional&gt;

...

struct QueueFamilyIndices {
    std::optional&lt;uint32_t&gt; graphicsFamily;
};

QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;
    // Assign index to queue families that could be found
    return indices;
}
</code></pre>
<p>We can now begin to actually implement <code>findQueueFamilies</code>:</p>
<pre><code class="language-c++">QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
    QueueFamilyIndices indices;

    ...

    return indices;
}
</code></pre>
<p>The process of retrieving the list of queue families is exactly what you expect
and uses <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetPhysicalDeviceQueueFamilyProperties.html"><code>vkGetPhysicalDeviceQueueFamilyProperties</code></a>:</p>
<pre><code class="language-c++">uint32_t queueFamilyCount = 0;
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);

std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data());
</code></pre>
<p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkQueueFamilyProperties.html"><code>VkQueueFamilyProperties</code></a> struct contains some details about the queue family,
including the type of operations that are supported and the number of queues
that can be created based on that family. We need to find at least one queue
family that supports <code>VK_QUEUE_GRAPHICS_BIT</code>.</p>
<p class="my-note">
æ³¨ï¼ VkQueueFamilyProperties åå«å¦ä¸å±æ§ï¼<br />
<ul class="my-note">
    <li>queueFlags ï¼ Queue Family ä¸­ç Queue çè½å</li>
    <li>queueCount ï¼ Queue Family éæå ä¸ª Queue ï¼æ¯ä¸ª Queue Family <b>å¿é¡»</b> æ¯æè³å°ä¸ä¸ª Queue</li>
    <li>timestampValidBits ï¼ éè¿ vkCmdWriteTimestamp2 æ vkCmdWriteTimestamp åå¥çæ¶é´æ³çææä½</li>
    <li>minImageTransferGranularity ï¼è½å¤æ¯æç Image ä¼ è¾æä½çæå°ç²åº¦</li>
</ul>
</p>
<pre><code class="language-c++">int i = 0;
for (const auto&amp; queueFamily : queueFamilies) {
    if (queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) {
        indices.graphicsFamily = i;
    }

    i++;
}
</code></pre>
<p>Now that we have this fancy queue family lookup function, we can use it as a
check in the <code>isDeviceSuitable</code> function to ensure that the device can process
the commands we want to use:</p>
<pre><code class="language-c++">bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    return indices.graphicsFamily.has_value();
}
</code></pre>
<p>To make this a little bit more convenient, we'll also add a generic check to the
struct itself:</p>
<pre><code class="language-c++">struct QueueFamilyIndices {
    std::optional&lt;uint32_t&gt; graphicsFamily;

    bool isComplete() {
        return graphicsFamily.has_value();
    }
};

...

bool isDeviceSuitable(VkPhysicalDevice device) {
    QueueFamilyIndices indices = findQueueFamilies(device);

    return indices.isComplete();
}
</code></pre>
<p>We can now also use this for an early exit from <code>findQueueFamilies</code>:</p>
<pre><code class="language-c++">for (const auto&amp; queueFamily : queueFamilies) {
    ...

    if (indices.isComplete()) {
        break;
    }

    i++;
}
</code></pre>
<p>Great, that's all we need for now to find the right physical device! The next
step is to <a href="Logical_device_and_queues.html">create a logical device</a>
to interface with it.</p>
<p><a href="../../../code/03_physical_device_selection.cpp">C++ code</a></p>

        <nav>
        <ul class="pager">
            <li><a href="../../../en/Drawing_a_triangle/Setup/Validation_layers.html">Previous</a></li>            <li><a href="../../../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Next</a></li>        </ul>
    </nav>
    
        <div id="waldo-tag-4314"></div>
    
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </article>

                </div>
            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../../../themes/vulkan/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../../../themes/vulkan/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../../../themes/vulkan/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../../../tipuesearch/tipuesearch_set.js"></script>
        <script type="text/javascript" src="../../../tipuesearch/tipuesearch.min.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(document).ready(function() {
                $('#tipue_search_input').tipuesearch({
                    'show': 10,
                    'mode': 'json',
                    'base_url': '../../../'
                });
            });
        </script>
    
</body>
</html>
