<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Descriptor set layout and buffer - Vulkan Tutorial</title>
    <meta name="description" content="A tutorial that teaches you everything it takes to render 3D graphics with the Vulkan API. It covers everything from Windows/Linux setup to rendering and debugging." />
    <meta name="author" content="Alexander Overvoorde">
    <meta charset="UTF-8">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    
    <!-- CSS -->
    <link href='../../themes/vulkan/css/theme.min.css' rel='stylesheet' type='text/css'><link href='../../themes/vulkan/css/theme-blue.min.css' rel='stylesheet' type='text/css'><link href='../../themes/vulkan/css/css.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<div class="container-fluid fluid-height wrapper">
    <div class="row columns content">
        <div class="left-column article-tree col-sm-3 hidden-print">
            <!-- For Mobile -->
            <div class="responsive-collapse">
                <button type="button" class="btn btn-sidebar" id="menu-spinner-button">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div id="sub-nav-collapse" class="sub-nav-collapse">
                <div class="nav-logo">
                    Vulkan Tutorial
                </div>

                <!-- Language picker -->
                <div class="language-picker">
                <a href="/Introduction">English</a>                </div>

                <!-- Navigation -->
                <div style="padding-top: 20px; padding-bottom: 20px; background: #272525">
                <ul class='Nav'><li class='Nav__item '><a href="../../en/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../en/Overview.html">Overview</a></li><li class='Nav__item '><a href="../../en/Development_environment.html">Development environment</a></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing a triangle</a><ul class='Nav'><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Setup</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Base_code.html">Base code</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Instance.html">Instance</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Validation_layers.html">Validation layers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families.html">Physical devices and queue families</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Logical device and queues</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Presentation/Window_surface.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Presentation</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Window_surface.html">Window surface</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Swap_chain.html">Swap chain</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Image_views.html">Image views</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Graphics pipeline basics</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules.html">Shader modules</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions.html">Fixed functions</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes.html">Render passes</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion.html">Conclusion</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Drawing/Framebuffers.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Framebuffers.html">Framebuffers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Command_buffers.html">Command buffers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Rendering_and_presentation.html">Rendering and presentation</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Frames_in_flight.html">Frames in flight</a></li></ul></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Swap_chain_recreation.html">Swap chain recreation</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Vertex_buffers/Vertex_input_description.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Vertex buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Vertex_buffers/Vertex_input_description.html">Vertex input description</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Vertex_buffer_creation.html">Vertex buffer creation</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Staging_buffer.html">Staging buffer</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Index_buffer.html">Index buffer</a></li></ul></li><li class='Nav__item Nav__item--open has-children'><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Uniform buffers</a><ul class='Nav'><li class='Nav__item Nav__item--active'><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Descriptor set layout and buffer</a></li><li class='Nav__item '><a href="../../en/Uniform_buffers/Descriptor_pool_and_sets.html">Descriptor pool and sets</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Texture_mapping/Images.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Texture mapping</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Texture_mapping/Images.html">Images</a></li><li class='Nav__item '><a href="../../en/Texture_mapping/Image_view_and_sampler.html">Image view and sampler</a></li><li class='Nav__item '><a href="../../en/Texture_mapping/Combined_image_sampler.html">Combined image sampler</a></li></ul></li><li class='Nav__item '><a href="../../en/Depth_buffering.html">Depth buffering</a></li><li class='Nav__item '><a href="../../en/Loading_models.html">Loading models</a></li><li class='Nav__item '><a href="../../en/Generating_Mipmaps.html">Generating Mipmaps</a></li><li class='Nav__item '><a href="../../en/Multisampling.html">Multisampling</a></li><li class='Nav__item '><a href="../../en/Compute_Shader.html">Compute Shader</a></li><li class='Nav__item '><a href="../../en/FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../../en/Privacy_policy.html">Privacy policy</a></li></ul>                </div>

                <div class="sidebar-links">
                    
                        <!-- Links -->
                        <a href="https://github.com/Overv/VulkanTutorial" target="_blank">GitHub Repository</a><br><a href="https://www.paypal.me/AOvervoorde" target="_blank">Support the website</a><br><br><a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/" target="_blank">Vulkan Specification</a><br><a href="https://lunarg.com/vulkan-sdk/" target="_blank">LunarG Vulkan SDK</a><br><a href="https://github.com/KhronosGroup/Vulkan-Guide" target="_blank">Vulkan Guide</a><br><a href="https://vulkan.gpuinfo.org/" target="_blank">Vulkan Hardware Database</a><br><br><a href="https://github.com/bwasty/vulkan-tutorial-rs" target="_blank">Rust code</a><br><a href="https://github.com/Naitsirc98/Vulkan-Tutorial-Java" target="_blank">Java code</a><br><a href="https://github.com/vkngwrapper/vulkan-tutorial" target="_blank">Go code</a><br><a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles" target="_blank">Visual Studio 2019 samples</a><br><a href="https://github.com/fangcun010/VulkanTutorialCN" target="_blank">Chinese translation</a><br>
                        <div id="toggleCodeBlock">
                                                </div>

                        <!-- Twitter -->
                                                            </div>

                <div style="color: #666; padding: 0 20px 0 20px; font-size: 90%">
                    This site is not affiliated with or endorsed by the Khronos Group. VulkanÂ® and the Vulkan logo are trademarks of the Khronos Group Inc.
                </div>
            </div>
        </div>
        <div class="right-column  content-area col-sm-9">
            <div class="content-page" style="position: relative;">
                <div class="adbox-side" style="position: absolute; left: calc(100% + 50px);">
                    <div id="waldo-tag-4310"></div>
                </div>

                <div class="adbox-side" style="position: absolute; left: -350px">
                    <div id="waldo-tag-4312"></div>
                </div>

                                    <div id="tipue_search_content" style="display:none"></div>
                
                <div class="doc_content">
                    <article>
            <div class="page-header">
            <h1>Descriptor set layout and buffer</h1>
        </div>
    
    <ul class="TableOfContents">
<li>
<p><a href="#page_Introduction">Introduction</a></p>
</li>
<li>
<p><a href="#page_Vertex-shader">Vertex shader</a></p>
</li>
<li>
<p><a href="#page_Descriptor-set-layout">Descriptor set layout</a></p>
</li>
<li>
<p><a href="#page_Uniform-buffer">Uniform buffer</a></p>
</li>
<li>
<p><a href="#page_Updating-uniform-data">Updating uniform data</a></p>
</li>
</ul>
<h2 id="page_Introduction">Introduction</h2>
<p>We're now able to pass arbitrary attributes to the vertex shader for each
vertex, but what about global variables? We're going to move on to 3D graphics
from this chapter on and that requires a model-view-projection matrix. We could
include it as vertex data, but that's a waste of memory and it would require us
to update the vertex buffer whenever the transformation changes. The
transformation could easily change every single frame.</p>
<p>The right way to tackle this in Vulkan is to use <em>resource descriptors</em>. A
descriptor is a way for shaders to freely access resources like buffers and
images. We're going to set up a buffer that contains the transformation matrices
and have the vertex shader access them through a descriptor. Usage of
descriptors consists of three parts:</p>
<ul>
<li>Specify a descriptor set layout during pipeline creation</li>
<li>Allocate a descriptor set from a descriptor pool</li>
<li>Bind the descriptor set during rendering</li>
</ul>
<p>The <em>descriptor set layout</em> specifies the types of resources that are going to be
accessed by the pipeline, just like a render pass specifies the types of
attachments that will be accessed. A <em>descriptor set</em> specifies the actual
buffer or image resources that will be bound to the descriptors, just like a
framebuffer specifies the actual image views to bind to render pass attachments.
The descriptor set is then bound for the drawing commands just like the vertex
buffers and framebuffer.</p>
<p>There are many types of descriptors, but in this chapter we'll work with uniform
buffer objects (UBO). We'll look at other types of descriptors in future
chapters, but the basic process is the same. Let's say we have the data we want
the vertex shader to have in a C struct like this:</p>
<pre><code class="language-c++">struct UniformBufferObject {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
</code></pre>
<p>Then we can copy the data to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkBuffer.html"><code>VkBuffer</code></a> and access it through a uniform buffer
object descriptor from the vertex shader like this:</p>
<pre><code class="language-glsl">layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</code></pre>
<p>We're going to update the model, view and projection matrices every frame to
make the rectangle from the previous chapter spin around in 3D.</p>
<h2 id="page_Vertex-shader">Vertex shader</h2>
<p>Modify the vertex shader to include the uniform buffer object like it was
specified above. I will assume that you are familiar with MVP transformations.
If you're not, see <a href="https://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/" class="Link--external">the resource</a>
mentioned in the first chapter.</p>
<pre><code class="language-glsl">#version 450

layout(binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

layout(location = 0) in vec2 inPosition;
layout(location = 1) in vec3 inColor;

layout(location = 0) out vec3 fragColor;

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0);
    fragColor = inColor;
}
</code></pre>
<p>Note that the order of the <code>uniform</code>, <code>in</code> and <code>out</code> declarations doesn't
matter. The <code>binding</code> directive is similar to the <code>location</code> directive for
attributes. We're going to reference this binding in the descriptor set layout. The
line with <code>gl_Position</code> is changed to use the transformations to compute the
final position in clip coordinates. Unlike the 2D triangles, the last component
of the clip coordinates may not be <code>1</code>, which will result in a division when
converted to the final normalized device coordinates on the screen. This is used
in perspective projection as the <em>perspective division</em> and is essential for
making closer objects look larger than objects that are further away.</p>
<h2 id="page_Descriptor-set-layout">Descriptor set layout</h2>
<p>The next step is to define the UBO on the C++ side and to tell Vulkan about this
descriptor in the vertex shader.</p>
<pre><code class="language-c++">struct UniformBufferObject {
    glm::mat4 model;
    glm::mat4 view;
    glm::mat4 proj;
};
</code></pre>
<p>We can exactly match the definition in the shader using data types in GLM. The
data in the matrices is binary compatible with the way the shader expects it, so
we can later just <code>memcpy</code> a <code>UniformBufferObject</code> to a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkBuffer.html"><code>VkBuffer</code></a>.</p>
<p>We need to provide details about every descriptor binding used in the shaders
for pipeline creation, just like we had to do for every vertex attribute and its
<code>location</code> index. We'll set up a new function to define all of this information
called <code>createDescriptorSetLayout</code>. It should be called right before pipeline
creation, because we're going to need it there.</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    createDescriptorSetLayout();
    createGraphicsPipeline();
    ...
}

...

void createDescriptorSetLayout() {

}
</code></pre>
<p>Every binding needs to be described through a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkDescriptorSetLayoutBinding.html"><code>VkDescriptorSetLayoutBinding</code></a>
struct.</p>
<pre><code class="language-c++">void createDescriptorSetLayout() {
    VkDescriptorSetLayoutBinding uboLayoutBinding{};
    uboLayoutBinding.binding = 0;
    uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
    uboLayoutBinding.descriptorCount = 1;
}
</code></pre>
<p>The first two fields specify the <code>binding</code> used in the shader and the type of
descriptor, which is a uniform buffer object. It is possible for the shader
variable to represent an array of uniform buffer objects, and <code>descriptorCount</code>
specifies the number of values in the array. This could be used to specify a
transformation for each of the bones in a skeleton for skeletal animation, for
example. Our MVP transformation is in a single uniform buffer object, so we're
using a <code>descriptorCount</code> of <code>1</code>.</p>
<pre><code class="language-c++">uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT;
</code></pre>
<p>We also need to specify in which shader stages the descriptor is going to be
referenced. The <code>stageFlags</code> field can be a combination of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkShaderStageFlagBits.html"><code>VkShaderStageFlagBits</code></a> values
or the value <code>VK_SHADER_STAGE_ALL_GRAPHICS</code>. In our case, we're only referencing
the descriptor from the vertex shader.</p>
<pre><code class="language-c++">uboLayoutBinding.pImmutableSamplers = nullptr; // Optional
</code></pre>
<p>The <code>pImmutableSamplers</code> field is only relevant for image sampling related
descriptors, which we'll look at later. You can leave this to its default value.</p>
<p>All of the descriptor bindings are combined into a single
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkDescriptorSetLayout.html"><code>VkDescriptorSetLayout</code></a> object. Define a new class member above
<code>pipelineLayout</code>:</p>
<pre><code class="language-c++">VkDescriptorSetLayout descriptorSetLayout;
VkPipelineLayout pipelineLayout;
</code></pre>
<p>We can then create it using <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCreateDescriptorSetLayout.html"><code>vkCreateDescriptorSetLayout</code></a>. This function accepts
a simple <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkDescriptorSetLayoutCreateInfo.html"><code>VkDescriptorSetLayoutCreateInfo</code></a> with the array of bindings:</p>
<pre><code class="language-c++">VkDescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
layoutInfo.bindingCount = 1;
layoutInfo.pBindings = &amp;uboLayoutBinding;

if (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, nullptr, &amp;descriptorSetLayout) != VK_SUCCESS) {
    throw std::runtime_error(&quot;failed to create descriptor set layout!&quot;);
}
</code></pre>
<p>We need to specify the descriptor set layout during pipeline creation to tell
Vulkan which descriptors the shaders will be using. Descriptor set layouts are
specified in the pipeline layout object. Modify the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineLayoutCreateInfo.html"><code>VkPipelineLayoutCreateInfo</code></a>
to reference the layout object:</p>
<pre><code class="language-c++">VkPipelineLayoutCreateInfo pipelineLayoutInfo{};
pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutInfo.setLayoutCount = 1;
pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout;
</code></pre>
<p>You may be wondering why it's possible to specify multiple descriptor set
layouts here, because a single one already includes all of the bindings. We'll
get back to that in the next chapter, where we'll look into descriptor pools and
descriptor sets.</p>
<p>The descriptor set layout should stick around while we may create new graphics
pipelines i.e. until the program ends:</p>
<pre><code class="language-c++">void cleanup() {
    cleanupSwapChain();

    vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);

    ...
}
</code></pre>
<h2 id="page_Uniform-buffer">Uniform buffer</h2>
<p>In the next chapter we'll specify the buffer that contains the UBO data for the
shader, but we need to create this buffer first. We're going to copy new data to
the uniform buffer every frame, so it doesn't really make any sense to have a
staging buffer. It would just add extra overhead in this case and likely degrade
performance instead of improving it.</p>
<p>We should have multiple buffers, because multiple frames may be in flight at the same
time and we don't want to update the buffer in preparation of the next frame while a
previous one is still reading from it! Thus, we need to have as many uniform buffers
as we have frames in flight, and write to a uniform buffer that is not currently
being read by the GPU.</p>
<p>To that end, add new class members for <code>uniformBuffers</code>, and <code>uniformBuffersMemory</code>:</p>
<pre><code class="language-c++">VkBuffer indexBuffer;
VkDeviceMemory indexBufferMemory;

std::vector&lt;VkBuffer&gt; uniformBuffers;
std::vector&lt;VkDeviceMemory&gt; uniformBuffersMemory;
std::vector&lt;void*&gt; uniformBuffersMapped;
</code></pre>
<p>Similarly, create a new function <code>createUniformBuffers</code> that is called after
<code>createIndexBuffer</code> and allocates the buffers:</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    createVertexBuffer();
    createIndexBuffer();
    createUniformBuffers();
    ...
}

...

void createUniformBuffers() {
    VkDeviceSize bufferSize = sizeof(UniformBufferObject);

    uniformBuffers.resize(MAX_FRAMES_IN_FLIGHT);
    uniformBuffersMemory.resize(MAX_FRAMES_IN_FLIGHT);
    uniformBuffersMapped.resize(MAX_FRAMES_IN_FLIGHT);

    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        createBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i]);

        vkMapMemory(device, uniformBuffersMemory[i], 0, bufferSize, 0, &amp;uniformBuffersMapped[i]);
    }
}
</code></pre>
<p>We map the buffer right after creation using <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkMapMemory.html"><code>vkMapMemory</code></a> to get a pointer to which we can write the data later on. The buffer stays mapped to this pointer for the application's whole lifetime. This technique is called <strong>&quot;persistent mapping&quot;</strong> and works on all Vulkan implementations. Not having to map the buffer every time we need to update it increases performances, as mapping is not free.</p>
<p>The uniform data will be used for all draw calls, so the buffer containing it should only be destroyed when we stop rendering.</p>
<pre><code class="language-c++">void cleanup() {
    ...

    for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) {
        vkDestroyBuffer(device, uniformBuffers[i], nullptr);
        vkFreeMemory(device, uniformBuffersMemory[i], nullptr);
    }

    vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr);

    ...

}
</code></pre>
<h2 id="page_Updating-uniform-data">Updating uniform data</h2>
<p>Create a new function <code>updateUniformBuffer</code> and add a call to it from the <code>drawFrame</code> function before submitting the next frame:</p>
<pre><code class="language-c++">void drawFrame() {
    ...

    updateUniformBuffer(currentFrame);

    ...

    VkSubmitInfo submitInfo{};
    submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;

    ...
}

...

void updateUniformBuffer(uint32_t currentImage) {

}
</code></pre>
<p>This function will generate a new transformation every frame to make the
geometry spin around. We need to include two new headers to implement this
functionality:</p>
<pre><code class="language-c++">#define GLM_FORCE_RADIANS
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;

#include &lt;chrono&gt;
</code></pre>
<p>The <code>glm/gtc/matrix_transform.hpp</code> header exposes functions that can be used to
generate model transformations like <code>glm::rotate</code>, view transformations like
<code>glm::lookAt</code> and projection transformations like <code>glm::perspective</code>. The
<code>GLM_FORCE_RADIANS</code> definition is necessary to make sure that functions like
<code>glm::rotate</code> use radians as arguments, to avoid any possible confusion.</p>
<p>The <code>chrono</code> standard library header exposes functions to do precise
timekeeping. We'll use this to make sure that the geometry rotates 90 degrees
per second regardless of frame rate.</p>
<pre><code class="language-c++">void updateUniformBuffer(uint32_t currentImage) {
    static auto startTime = std::chrono::high_resolution_clock::now();

    auto currentTime = std::chrono::high_resolution_clock::now();
    float time = std::chrono::duration&lt;float, std::chrono::seconds::period&gt;(currentTime - startTime).count();
}
</code></pre>
<p>The <code>updateUniformBuffer</code> function will start out with some logic to calculate
the time in seconds since rendering has started with floating point accuracy.</p>
<p>We will now define the model, view and projection transformations in the
uniform buffer object. The model rotation will be a simple rotation around the
Z-axis using the <code>time</code> variable:</p>
<pre><code class="language-c++">UniformBufferObject ubo{};
ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
</code></pre>
<p>The <code>glm::rotate</code> function takes an existing transformation, rotation angle and
rotation axis as parameters. The <code>glm::mat4(1.0f)</code> constructor returns an
identity matrix. Using a rotation angle of <code>time * glm::radians(90.0f)</code>
accomplishes the purpose of rotation 90 degrees per second.</p>
<pre><code class="language-c++">ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
</code></pre>
<p>For the view transformation I've decided to look at the geometry from above at a
45 degree angle. The <code>glm::lookAt</code> function takes the eye position, center
position and up axis as parameters.</p>
<pre><code class="language-c++">ubo.proj = glm::perspective(glm::radians(45.0f), swapChainExtent.width / (float) swapChainExtent.height, 0.1f, 10.0f);
</code></pre>
<p>I've chosen to use a perspective projection with a 45 degree vertical
field-of-view. The other parameters are the aspect ratio, near and far
view planes. It is important to use the current swap chain extent to calculate
the aspect ratio to take into account the new width and height of the window
after a resize.</p>
<pre><code class="language-c++">ubo.proj[1][1] *= -1;
</code></pre>
<p>GLM was originally designed for OpenGL, where the Y coordinate of the clip
coordinates is inverted. The easiest way to compensate for that is to flip the
sign on the scaling factor of the Y axis in the projection matrix. If you don't
do this, then the image will be rendered upside down.</p>
<p>All of the transformations are defined now, so we can copy the data in the
uniform buffer object to the current uniform buffer. This happens in exactly the same
way as we did for vertex buffers, except without a staging buffer. As noted earlier, we only map the uniform buffer once, so we can directly write to it without having to map again:</p>
<pre><code class="language-c++">memcpy(uniformBuffersMapped[currentImage], &amp;ubo, sizeof(ubo));
</code></pre>
<p>Using a UBO this way is not the most efficient way to pass frequently changing
values to the shader. A more efficient way to pass a small buffer of data to
shaders are <em>push constants</em>. We may look at these in a future chapter.</p>
<p>In the next chapter we'll look at descriptor sets, which will actually bind the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkBuffer.html"><code>VkBuffer</code></a>s to the uniform buffer descriptors so that the shader can access this
transformation data.</p>
<p><a href="../../code/22_descriptor_set_layout.cpp">C++ code</a> /
<a href="../../code/22_shader_ubo.vert">Vertex shader</a> /
<a href="../../code/22_shader_ubo.frag">Fragment shader</a></p>

        <nav>
        <ul class="pager">
            <li><a href="../../en/Vertex_buffers/Index_buffer.html">Previous</a></li>            <li><a href="../../en/Uniform_buffers/Descriptor_pool_and_sets.html">Next</a></li>        </ul>
    </nav>
    
        <div id="waldo-tag-4314"></div>
    
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </article>

                </div>
            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../../themes/vulkan/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../../themes/vulkan/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../../themes/vulkan/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../../tipuesearch/tipuesearch_set.js"></script>
        <script type="text/javascript" src="../../tipuesearch/tipuesearch.min.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(document).ready(function() {
                $('#tipue_search_input').tipuesearch({
                    'show': 10,
                    'mode': 'json',
                    'base_url': '../../'
                });
            });
        </script>
    
</body>
</html>
