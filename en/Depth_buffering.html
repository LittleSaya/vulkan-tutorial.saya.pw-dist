<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Depth buffering - Vulkan Tutorial</title>
    <meta name="description" content="A tutorial that teaches you everything it takes to render 3D graphics with the Vulkan API. It covers everything from Windows/Linux setup to rendering and debugging." />
    <meta name="author" content="Alexander Overvoorde">
    <meta charset="UTF-8">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    
    <!-- CSS -->
    <link href='../themes/vulkan/css/theme.min.css' rel='stylesheet' type='text/css'><link href='../themes/vulkan/css/theme-blue.min.css' rel='stylesheet' type='text/css'><link href='../themes/vulkan/css/css.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<div class="container-fluid fluid-height wrapper">
    <div class="row columns content">
        <div class="left-column article-tree col-sm-3 hidden-print">
            <!-- For Mobile -->
            <div class="responsive-collapse">
                <button type="button" class="btn btn-sidebar" id="menu-spinner-button">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div id="sub-nav-collapse" class="sub-nav-collapse">
                <div class="nav-logo">
                    Vulkan Tutorial
                </div>

                <!-- Language picker -->
                <div class="language-picker">
                <a href="/Introduction">English</a>                </div>

                <!-- Navigation -->
                <div style="padding-top: 20px; padding-bottom: 20px; background: #272525">
                <ul class='Nav'><li class='Nav__item '><a href="../en/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../en/Overview.html">Overview</a></li><li class='Nav__item '><a href="../en/Development_environment.html">Development environment</a></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing a triangle</a><ul class='Nav'><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Setup</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Base_code.html">Base code</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Instance.html">Instance</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Validation_layers.html">Validation layers</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families.html">Physical devices and queue families</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Logical device and queues</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Presentation/Window_surface.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Presentation</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Presentation/Window_surface.html">Window surface</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Presentation/Swap_chain.html">Swap chain</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Presentation/Image_views.html">Image views</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Graphics pipeline basics</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules.html">Shader modules</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions.html">Fixed functions</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes.html">Render passes</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion.html">Conclusion</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Drawing/Framebuffers.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Framebuffers.html">Framebuffers</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Command_buffers.html">Command buffers</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Rendering_and_presentation.html">Rendering and presentation</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/X_Object_relationships.html">X Object relationships</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Frames_in_flight.html">Frames in flight</a></li></ul></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Swap_chain_recreation.html">Swap chain recreation</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Vertex_buffers/Vertex_input_description.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Vertex buffers</a><ul class='Nav'><li class='Nav__item '><a href="../en/Vertex_buffers/Vertex_input_description.html">Vertex input description</a></li><li class='Nav__item '><a href="../en/Vertex_buffers/Vertex_buffer_creation.html">Vertex buffer creation</a></li><li class='Nav__item '><a href="../en/Vertex_buffers/Staging_buffer.html">Staging buffer</a></li><li class='Nav__item '><a href="../en/Vertex_buffers/Index_buffer.html">Index buffer</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Uniform buffers</a><ul class='Nav'><li class='Nav__item '><a href="../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Descriptor set layout and buffer</a></li><li class='Nav__item '><a href="../en/Uniform_buffers/Descriptor_pool_and_sets.html">Descriptor pool and sets</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Texture_mapping/Images.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Texture mapping</a><ul class='Nav'><li class='Nav__item '><a href="../en/Texture_mapping/Images.html">Images</a></li><li class='Nav__item '><a href="../en/Texture_mapping/Image_view_and_sampler.html">Image view and sampler</a></li><li class='Nav__item '><a href="../en/Texture_mapping/Combined_image_sampler.html">Combined image sampler</a></li></ul></li><li class='Nav__item Nav__item--active'><a href="../en/Depth_buffering.html">Depth buffering</a></li><li class='Nav__item '><a href="../en/Loading_models.html">Loading models</a></li><li class='Nav__item '><a href="../en/Generating_Mipmaps.html">Generating Mipmaps</a></li><li class='Nav__item '><a href="../en/Multisampling.html">Multisampling</a></li><li class='Nav__item '><a href="../en/Compute_Shader.html">Compute Shader</a></li><li class='Nav__item '><a href="../en/FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../en/Privacy_policy.html">Privacy policy</a></li></ul>                </div>

                <div class="sidebar-links">
                    
                        <!-- Links -->
                        <a href="https://github.com/Overv/VulkanTutorial" target="_blank">GitHub Repository</a><br><a href="https://www.paypal.me/AOvervoorde" target="_blank">Support the website</a><br><br><a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/" target="_blank">Vulkan Specification</a><br><a href="https://lunarg.com/vulkan-sdk/" target="_blank">LunarG Vulkan SDK</a><br><a href="https://github.com/KhronosGroup/Vulkan-Guide" target="_blank">Vulkan Guide</a><br><a href="https://vulkan.gpuinfo.org/" target="_blank">Vulkan Hardware Database</a><br><br><a href="https://github.com/bwasty/vulkan-tutorial-rs" target="_blank">Rust code</a><br><a href="https://github.com/Naitsirc98/Vulkan-Tutorial-Java" target="_blank">Java code</a><br><a href="https://github.com/vkngwrapper/vulkan-tutorial" target="_blank">Go code</a><br><a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles" target="_blank">Visual Studio 2019 samples</a><br><a href="https://github.com/fangcun010/VulkanTutorialCN" target="_blank">Chinese translation</a><br>
                        <div id="toggleCodeBlock">
                                                </div>

                        <!-- Twitter -->
                                                            </div>

                <div style="color: #666; padding: 0 20px 0 20px; font-size: 90%">
                    This site is not affiliated with or endorsed by the Khronos Group. VulkanÂ® and the Vulkan logo are trademarks of the Khronos Group Inc.
                </div>
            </div>
        </div>
        <div class="right-column  content-area col-sm-9">
            <div class="content-page" style="position: relative;">
                <div class="adbox-side" style="position: absolute; left: calc(100% + 50px);">
                    <div id="waldo-tag-4310"></div>
                </div>

                <div class="adbox-side" style="position: absolute; left: -350px">
                    <div id="waldo-tag-4312"></div>
                </div>

                                    <div id="tipue_search_content" style="display:none"></div>
                
                <div class="doc_content">
                    <article>
            <div class="page-header">
            <h1>Depth buffering</h1>
        </div>
    
    <ul class="TableOfContents">
<li>
<p><a href="#page_Introduction">Introduction</a></p>
</li>
<li>
<p><a href="#page_3D-geometry">3D geometry</a></p>
</li>
<li>
<p><a href="#page_Depth-image-and-view">Depth image and view</a></p>
<ul class="TableOfContents">
<li>
<p><a href="#page_Explicitly-transitioning-the-depth-image">Explicitly transitioning the depth image</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#page_Render-pass">Render pass</a></p>
</li>
<li>
<p><a href="#page_Framebuffer">Framebuffer</a></p>
</li>
<li>
<p><a href="#page_Clear-values">Clear values</a></p>
</li>
<li>
<p><a href="#page_Depth-and-stencil-state">Depth and stencil state</a></p>
</li>
<li>
<p><a href="#page_Handling-window-resize">Handling window resize</a></p>
</li>
</ul>
<h2 id="page_Introduction">Introduction</h2>
<p>The geometry we've worked with so far is projected into 3D, but it's still
completely flat. In this chapter we're going to add a Z coordinate to the
position to prepare for 3D meshes. We'll use this third coordinate to place a
square over the current square to see a problem that arises when geometry is not
sorted by depth.</p>
<h2 id="page_3D-geometry">3D geometry</h2>
<p>Change the <code>Vertex</code> struct to use a 3D vector for the position, and update the
<code>format</code> in the corresponding <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkVertexInputAttributeDescription.html"><code>VkVertexInputAttributeDescription</code></a>:</p>
<pre><code class="language-c++">struct Vertex {
    glm::vec3 pos;
    glm::vec3 color;
    glm::vec2 texCoord;

    ...

    static std::array&lt;VkVertexInputAttributeDescription, 3&gt; getAttributeDescriptions() {
        std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions{};

        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = offsetof(Vertex, pos);

        ...
    }
};
</code></pre>
<p>Next, update the vertex shader to accept and transform 3D coordinates as input.
Don't forget to recompile it afterwards!</p>
<pre><code class="language-glsl">layout(location = 0) in vec3 inPosition;

...

void main() {
    gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 1.0);
    fragColor = inColor;
    fragTexCoord = inTexCoord;
}
</code></pre>
<p>Lastly, update the <code>vertices</code> container to include Z coordinates:</p>
<pre><code class="language-c++">const std::vector&lt;Vertex&gt; vertices = {
    {{-0.5f, -0.5f, 0.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{0.5f, -0.5f, 0.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{0.5f, 0.5f, 0.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-0.5f, 0.5f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}
};
</code></pre>
<p>If you run your application now, then you should see exactly the same result as
before. It's time to add some extra geometry to make the scene more interesting,
and to demonstrate the problem that we're going to tackle in this chapter.
Duplicate the vertices to define positions for a square right under the current
one like this:</p>
<p><img src="/images/extra_square.svg" alt="" /></p>
<p>Use Z coordinates of <code>-0.5f</code> and add the appropriate indices for the extra
square:</p>
<pre><code class="language-c++">const std::vector&lt;Vertex&gt; vertices = {
    {{-0.5f, -0.5f, 0.0f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{0.5f, -0.5f, 0.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{0.5f, 0.5f, 0.0f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-0.5f, 0.5f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}},

    {{-0.5f, -0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}, {0.0f, 0.0f}},
    {{0.5f, -0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f}},
    {{0.5f, 0.5f, -0.5f}, {0.0f, 0.0f, 1.0f}, {1.0f, 1.0f}},
    {{-0.5f, 0.5f, -0.5f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f}}
};

const std::vector&lt;uint16_t&gt; indices = {
    0, 1, 2, 2, 3, 0,
    4, 5, 6, 6, 7, 4
};
</code></pre>
<p>Run your program now and you'll see something resembling an Escher illustration:</p>
<p><img src="/images/depth_issues.png" alt="" /></p>
<p>The problem is that the fragments of the lower square are drawn over the
fragments of the upper square, simply because it comes later in the index array.
There are two ways to solve this:</p>
<ul>
<li>Sort all of the draw calls by depth from back to front</li>
<li>Use depth testing with a depth buffer</li>
</ul>
<p>The first approach is commonly used for drawing transparent objects, because
order-independent transparency is a difficult challenge to solve. However, the
problem of ordering fragments by depth is much more commonly solved using a
<em>depth buffer</em>. A depth buffer is an additional attachment that stores the depth
for every position, just like the color attachment stores the color of every
position. Every time the rasterizer produces a fragment, the depth test will
check if the new fragment is closer than the previous one. If it isn't, then the
new fragment is discarded. A fragment that passes the depth test writes its own
depth to the depth buffer. It is possible to manipulate this value from the
fragment shader, just like you can manipulate the color output.</p>
<pre><code class="language-c++">#define GLM_FORCE_RADIANS
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/matrix_transform.hpp&gt;
</code></pre>
<p>The perspective projection matrix generated by GLM will use the OpenGL depth
range of <code>-1.0</code> to <code>1.0</code> by default. We need to configure it to use the Vulkan
range of <code>0.0</code> to <code>1.0</code> using the <code>GLM_FORCE_DEPTH_ZERO_TO_ONE</code> definition.</p>
<h2 id="page_Depth-image-and-view">Depth image and view</h2>
<p>A depth attachment is based on an image, just like the color attachment. The
difference is that the swap chain will not automatically create depth images for us. We only need a single depth image, because only one draw operation is
running at once. The depth image will again require the trifecta of resources:
image, memory and image view.</p>
<pre><code class="language-c++">VkImage depthImage;
VkDeviceMemory depthImageMemory;
VkImageView depthImageView;
</code></pre>
<p>Create a new function <code>createDepthResources</code> to set up these resources:</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    createCommandPool();
    createDepthResources();
    createTextureImage();
    ...
}

...

void createDepthResources() {

}
</code></pre>
<p>Creating a depth image is fairly straightforward. It should have the same
resolution as the color attachment, defined by the swap chain extent, an image
usage appropriate for a depth attachment, optimal tiling and device local
memory. The only question is: what is the right format for a depth image? The
format must contain a depth component, indicated by <code>_D??_</code> in the <code>VK_FORMAT_</code>.</p>
<p>Unlike the texture image, we don't necessarily need a specific format, because
we won't be directly accessing the texels from the program. It just needs to
have a reasonable accuracy, at least 24 bits is common in real-world
applications. There are several formats that fit this requirement:</p>
<ul>
<li>
<code>VK_FORMAT_D32_SFLOAT</code>: 32-bit float for depth</li>
<li>
<code>VK_FORMAT_D32_SFLOAT_S8_UINT</code>: 32-bit signed float for depth and 8 bit
stencil component</li>
<li>
<code>VK_FORMAT_D24_UNORM_S8_UINT</code>: 24-bit float for depth and 8 bit stencil
component</li>
</ul>
<p>The stencil component is used for <a href="https://en.wikipedia.org/wiki/Stencil_buffer" class="Link--external">stencil tests</a>,
which is an additional test that can be combined with depth testing. We'll look
at this in a future chapter.</p>
<p>We could simply go for the <code>VK_FORMAT_D32_SFLOAT</code> format, because support for it
is extremely common (see the hardware database), but it's nice to add some extra
flexibility to our application where possible. We're going to write a function
<code>findSupportedFormat</code> that takes a list of candidate formats in order from most
desirable to least desirable, and checks which is the first one that is
supported:</p>
<pre><code class="language-c++">VkFormat findSupportedFormat(const std::vector&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {

}
</code></pre>
<p>The support of a format depends on the tiling mode and usage, so we must also
include these as parameters. The support of a format can be queried using
the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetPhysicalDeviceFormatProperties.html"><code>vkGetPhysicalDeviceFormatProperties</code></a> function:</p>
<pre><code class="language-c++">for (VkFormat format : candidates) {
    VkFormatProperties props;
    vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props);
}
</code></pre>
<p>The <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkFormatProperties.html"><code>VkFormatProperties</code></a> struct contains three fields:</p>
<ul>
<li>
<code>linearTilingFeatures</code>: Use cases that are supported with linear tiling</li>
<li>
<code>optimalTilingFeatures</code>: Use cases that are supported with optimal tiling</li>
<li>
<code>bufferFeatures</code>: Use cases that are supported for buffers</li>
</ul>
<p>Only the first two are relevant here, and the one we check depends on the
<code>tiling</code> parameter of the function:</p>
<pre><code class="language-c++">if (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) {
    return format;
} else if (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) {
    return format;
}
</code></pre>
<p>If none of the candidate formats support the desired usage, then we can either
return a special value or simply throw an exception:</p>
<pre><code class="language-c++">VkFormat findSupportedFormat(const std::vector&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features) {
    for (VkFormat format : candidates) {
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props);

        if (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) {
            return format;
        } else if (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) {
            return format;
        }
    }

    throw std::runtime_error(&quot;failed to find supported format!&quot;);
}
</code></pre>
<p>We'll use this function now to create a <code>findDepthFormat</code> helper function to
select a format with a depth component that supports usage as depth attachment:</p>
<pre><code class="language-c++">VkFormat findDepthFormat() {
    return findSupportedFormat(
        {VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT},
        VK_IMAGE_TILING_OPTIMAL,
        VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT
    );
}
</code></pre>
<p>Make sure to use the <code>VK_FORMAT_FEATURE_</code> flag instead of <code>VK_IMAGE_USAGE_</code> in
this case. All of these candidate formats contain a depth component, but the
latter two also contain a stencil component. We won't be using that yet, but we
do need to take that into account when performing layout transitions on images
with these formats. Add a simple helper function that tells us if the chosen
depth format contains a stencil component:</p>
<pre><code class="language-c++">bool hasStencilComponent(VkFormat format) {
    return format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT;
}
</code></pre>
<p>Call the function to find a depth format from <code>createDepthResources</code>:</p>
<pre><code class="language-c++">VkFormat depthFormat = findDepthFormat();
</code></pre>
<p>We now have all the required information to invoke our <code>createImage</code> and
<code>createImageView</code> helper functions:</p>
<pre><code class="language-c++">createImage(swapChainExtent.width, swapChainExtent.height, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);
depthImageView = createImageView(depthImage, depthFormat);
</code></pre>
<p>However, the <code>createImageView</code> function currently assumes that the subresource
is always the <code>VK_IMAGE_ASPECT_COLOR_BIT</code>, so we will need to turn that field
into a parameter:</p>
<pre><code class="language-c++">VkImageView createImageView(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags) {
    ...
    viewInfo.subresourceRange.aspectMask = aspectFlags;
    ...
}
</code></pre>
<p>Update all calls to this function to use the right aspect:</p>
<pre><code class="language-c++">swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT);
...
depthImageView = createImageView(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);
...
textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT);
</code></pre>
<p>That's it for creating the depth image. We don't need to map it or copy another
image to it, because we're going to clear it at the start of the render pass
like the color attachment.</p>
<h3 id="page_Explicitly-transitioning-the-depth-image">Explicitly transitioning the depth image</h3>
<p>We don't need to explicitly transition the layout of the image to a depth
attachment because we'll take care of this in the render pass. However, for
completeness I'll still describe the process in this section. You may skip it if
you like.</p>
<p>Make a call to <code>transitionImageLayout</code> at the end of the <code>createDepthResources</code>
function like so:</p>
<pre><code class="language-c++">transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL);
</code></pre>
<p>The undefined layout can be used as initial layout, because there are no
existing depth image contents that matter. We need to update some of the logic
in <code>transitionImageLayout</code> to use the right subresource aspect:</p>
<pre><code class="language-c++">if (newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT;

    if (hasStencilComponent(format)) {
        barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT;
    }
} else {
    barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
}
</code></pre>
<p>Although we're not using the stencil component, we do need to include it in the
layout transitions of the depth image.</p>
<p>Finally, add the correct access masks and pipeline stages:</p>
<pre><code class="language-c++">if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
    barrier.srcAccessMask = 0;
    barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
} else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
    barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
    barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;

    sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
} else if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) {
    barrier.srcAccessMask = 0;
    barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;

    sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
} else {
    throw std::invalid_argument(&quot;unsupported layout transition!&quot;);
}
</code></pre>
<p>The depth buffer will be read from to perform depth tests to see if a fragment
is visible, and will be written to when a new fragment is drawn. The reading
happens in the <code>VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT</code> stage and the
writing in the <code>VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT</code>. You should pick the
earliest pipeline stage that matches the specified operations, so that it is
ready for usage as depth attachment when it needs to be.</p>
<h2 id="page_Render-pass">Render pass</h2>
<p>We're now going to modify <code>createRenderPass</code> to include a depth attachment.
First specify the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkAttachmentDescription.html"><code>VkAttachmentDescription</code></a>:</p>
<pre><code class="language-c++">VkAttachmentDescription depthAttachment{};
depthAttachment.format = findDepthFormat();
depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;
depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
</code></pre>
<p>The <code>format</code> should be the same as the depth image itself. This time we don't
care about storing the depth data (<code>storeOp</code>), because it will not be used after
drawing has finished. This may allow the hardware to perform additional
optimizations. Just like the color buffer, we don't care about the previous
depth contents, so we can use <code>VK_IMAGE_LAYOUT_UNDEFINED</code> as <code>initialLayout</code>.</p>
<pre><code class="language-c++">VkAttachmentReference depthAttachmentRef{};
depthAttachmentRef.attachment = 1;
depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
</code></pre>
<p>Add a reference to the attachment for the first (and only) subpass:</p>
<pre><code class="language-c++">VkSubpassDescription subpass{};
subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
subpass.colorAttachmentCount = 1;
subpass.pColorAttachments = &amp;colorAttachmentRef;
subpass.pDepthStencilAttachment = &amp;depthAttachmentRef;
</code></pre>
<p>Unlike color attachments, a subpass can only use a single depth (+stencil)
attachment. It wouldn't really make any sense to do depth tests on multiple
buffers.</p>
<pre><code class="language-c++">std::array&lt;VkAttachmentDescription, 2&gt; attachments = {colorAttachment, depthAttachment};
VkRenderPassCreateInfo renderPassInfo{};
renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
renderPassInfo.attachmentCount = static_cast&lt;uint32_t&gt;(attachments.size());
renderPassInfo.pAttachments = attachments.data();
renderPassInfo.subpassCount = 1;
renderPassInfo.pSubpasses = &amp;subpass;
renderPassInfo.dependencyCount = 1;
renderPassInfo.pDependencies = &amp;dependency;
</code></pre>
<p>Next, update the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkSubpassDependency.html"><code>VkSubpassDependency</code></a> struct to refer to both
attachments.</p>
<pre><code class="language-c++">dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT;
dependency.srcAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT | VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;
dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
</code></pre>
<p>Finally, we need to extend our subpass dependencies to make sure that there is no conflict between the transitioning of the depth image and it being cleared as part of its load operation. The depth image is first accessed in the early fragment test pipeline stage and because we have a load operation that <em>clears</em>, we should specify the access mask for writes.</p>
<h2 id="page_Framebuffer">Framebuffer</h2>
<p>The next step is to modify the framebuffer creation to bind the depth image to
the depth attachment. Go to <code>createFramebuffers</code> and specify the depth image
view as second attachment:</p>
<pre><code class="language-c++">std::array&lt;VkImageView, 2&gt; attachments = {
    swapChainImageViews[i],
    depthImageView
};

VkFramebufferCreateInfo framebufferInfo{};
framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
framebufferInfo.renderPass = renderPass;
framebufferInfo.attachmentCount = static_cast&lt;uint32_t&gt;(attachments.size());
framebufferInfo.pAttachments = attachments.data();
framebufferInfo.width = swapChainExtent.width;
framebufferInfo.height = swapChainExtent.height;
framebufferInfo.layers = 1;
</code></pre>
<p>The color attachment differs for every swap chain image, but the same depth
image can be used by all of them because only a single subpass is running at the
same time due to our semaphores.</p>
<p>You'll also need to move the call to <code>createFramebuffers</code> to make sure that it
is called after the depth image view has actually been created:</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    createDepthResources();
    createFramebuffers();
    ...
}
</code></pre>
<h2 id="page_Clear-values">Clear values</h2>
<p>Because we now have multiple attachments with <code>VK_ATTACHMENT_LOAD_OP_CLEAR</code>, we
also need to specify multiple clear values. Go to <code>recordCommandBuffer</code> and
create an array of <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkClearValue.html"><code>VkClearValue</code></a> structs:</p>
<pre><code class="language-c++">std::array&lt;VkClearValue, 2&gt; clearValues{};
clearValues[0].color = {{0.0f, 0.0f, 0.0f, 1.0f}};
clearValues[1].depthStencil = {1.0f, 0};

renderPassInfo.clearValueCount = static_cast&lt;uint32_t&gt;(clearValues.size());
renderPassInfo.pClearValues = clearValues.data();
</code></pre>
<p>The range of depths in the depth buffer is <code>0.0</code> to <code>1.0</code> in Vulkan, where <code>1.0</code>
lies at the far view plane and <code>0.0</code> at the near view plane. The initial value
at each point in the depth buffer should be the furthest possible depth, which
is <code>1.0</code>.</p>
<p>Note that the order of <code>clearValues</code> should be identical to the order of your attachments.</p>
<h2 id="page_Depth-and-stencil-state">Depth and stencil state</h2>
<p>The depth attachment is ready to be used now, but depth testing still needs to
be enabled in the graphics pipeline. It is configured through the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkPipelineDepthStencilStateCreateInfo.html"><code>VkPipelineDepthStencilStateCreateInfo</code></a> struct:</p>
<pre><code class="language-c++">VkPipelineDepthStencilStateCreateInfo depthStencil{};
depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
depthStencil.depthTestEnable = VK_TRUE;
depthStencil.depthWriteEnable = VK_TRUE;
</code></pre>
<p>The <code>depthTestEnable</code> field specifies if the depth of new fragments should be
compared to the depth buffer to see if they should be discarded. The
<code>depthWriteEnable</code> field specifies if the new depth of fragments that pass the
depth test should actually be written to the depth buffer.</p>
<pre><code class="language-c++">depthStencil.depthCompareOp = VK_COMPARE_OP_LESS;
</code></pre>
<p>The <code>depthCompareOp</code> field specifies the comparison that is performed to keep or
discard fragments. We're sticking to the convention of lower depth = closer, so
the depth of new fragments should be <em>less</em>.</p>
<pre><code class="language-c++">depthStencil.depthBoundsTestEnable = VK_FALSE;
depthStencil.minDepthBounds = 0.0f; // Optional
depthStencil.maxDepthBounds = 1.0f; // Optional
</code></pre>
<p>The <code>depthBoundsTestEnable</code>, <code>minDepthBounds</code> and <code>maxDepthBounds</code> fields are
used for the optional depth bound test. Basically, this allows you to only keep
fragments that fall within the specified depth range. We won't be using this
functionality.</p>
<pre><code class="language-c++">depthStencil.stencilTestEnable = VK_FALSE;
depthStencil.front = {}; // Optional
depthStencil.back = {}; // Optional
</code></pre>
<p>The last three fields configure stencil buffer operations, which we also won't
be using in this tutorial. If you want to use these operations, then you will
have to make sure that the format of the depth/stencil image contains a stencil
component.</p>
<pre><code class="language-c++">pipelineInfo.pDepthStencilState = &amp;depthStencil;
</code></pre>
<p>Update the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkGraphicsPipelineCreateInfo.html"><code>VkGraphicsPipelineCreateInfo</code></a> struct to reference the depth stencil
state we just filled in. A depth stencil state must always be specified if the
render pass contains a depth stencil attachment.</p>
<p>If you run your program now, then you should see that the fragments of the
geometry are now correctly ordered:</p>
<p><img src="/images/depth_correct.png" alt="" /></p>
<h2 id="page_Handling-window-resize">Handling window resize</h2>
<p>The resolution of the depth buffer should change when the window is resized to
match the new color attachment resolution. Extend the <code>recreateSwapChain</code>
function to recreate the depth resources in that case:</p>
<pre><code class="language-c++">void recreateSwapChain() {
    int width = 0, height = 0;
    while (width == 0 || height == 0) {
        glfwGetFramebufferSize(window, &amp;width, &amp;height);
        glfwWaitEvents();
    }

    vkDeviceWaitIdle(device);

    cleanupSwapChain();

    createSwapChain();
    createImageViews();
    createDepthResources();
    createFramebuffers();
}
</code></pre>
<p>The cleanup operations should happen in the swap chain cleanup function:</p>
<pre><code class="language-c++">void cleanupSwapChain() {
    vkDestroyImageView(device, depthImageView, nullptr);
    vkDestroyImage(device, depthImage, nullptr);
    vkFreeMemory(device, depthImageMemory, nullptr);

    ...
}
</code></pre>
<p>Congratulations, your application is now finally ready to render arbitrary 3D
geometry and have it look right. We're going to try this out in the next chapter
by drawing a textured model!</p>
<p><a href="../code/27_depth_buffering.cpp">C++ code</a> /
<a href="../code/27_shader_depth.vert">Vertex shader</a> /
<a href="../code/27_shader_depth.frag">Fragment shader</a></p>

        <nav>
        <ul class="pager">
            <li><a href="../en/Texture_mapping/Combined_image_sampler.html">Previous</a></li>            <li><a href="../en/Loading_models.html">Next</a></li>        </ul>
    </nav>
    
        <div id="waldo-tag-4314"></div>
    
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </article>

                </div>
            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../themes/vulkan/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../themes/vulkan/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../themes/vulkan/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../tipuesearch/tipuesearch_set.js"></script>
        <script type="text/javascript" src="../tipuesearch/tipuesearch.min.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(document).ready(function() {
                $('#tipue_search_input').tipuesearch({
                    'show': 10,
                    'mode': 'json',
                    'base_url': '../'
                });
            });
        </script>
    
</body>
</html>
