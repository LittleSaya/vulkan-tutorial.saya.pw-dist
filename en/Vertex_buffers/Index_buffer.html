<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Index buffer - Vulkan Tutorial</title>
    <meta name="description" content="A tutorial that teaches you everything it takes to render 3D graphics with the Vulkan API. It covers everything from Windows/Linux setup to rendering and debugging." />
    <meta name="author" content="Alexander Overvoorde">
    <meta charset="UTF-8">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    
    <!-- CSS -->
    <link href='../../themes/vulkan/css/theme.min.css' rel='stylesheet' type='text/css'><link href='../../themes/vulkan/css/theme-blue.min.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<div class="container-fluid fluid-height wrapper">
    <div class="row columns content">
        <div class="left-column article-tree col-sm-3 hidden-print">
            <!-- For Mobile -->
            <div class="responsive-collapse">
                <button type="button" class="btn btn-sidebar" id="menu-spinner-button">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div id="sub-nav-collapse" class="sub-nav-collapse">
                <div class="nav-logo">
                    Vulkan Tutorial
                </div>

                <!-- Language picker -->
                <div class="language-picker">
                <a href="/Introduction">English</a>                </div>

                <!-- Navigation -->
                <div style="padding-top: 20px; padding-bottom: 20px; background: #272525">
                <ul class='Nav'><li class='Nav__item '><a href="../../en/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../en/Overview.html">Overview</a></li><li class='Nav__item '><a href="../../en/Development_environment.html">Development environment</a></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing a triangle</a><ul class='Nav'><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Setup</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Base_code.html">Base code</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Instance.html">Instance</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Validation_layers.html">Validation layers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families.html">Physical devices and queue families</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Logical device and queues</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Presentation/Window_surface.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Presentation</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Window_surface.html">Window surface</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Swap_chain.html">Swap chain</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Presentation/Image_views.html">Image views</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Graphics pipeline basics</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules.html">Shader modules</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions.html">Fixed functions</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes.html">Render passes</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion.html">Conclusion</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Drawing_a_triangle/Drawing/Framebuffers.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Framebuffers.html">Framebuffers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Command_buffers.html">Command buffers</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Rendering_and_presentation.html">Rendering and presentation</a></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Drawing/Frames_in_flight.html">Frames in flight</a></li></ul></li><li class='Nav__item '><a href="../../en/Drawing_a_triangle/Swap_chain_recreation.html">Swap chain recreation</a></li></ul></li><li class='Nav__item Nav__item--open has-children'><a href="../../en/Vertex_buffers/Vertex_input_description.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Vertex buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Vertex_buffers/Vertex_input_description.html">Vertex input description</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Vertex_buffer_creation.html">Vertex buffer creation</a></li><li class='Nav__item '><a href="../../en/Vertex_buffers/Staging_buffer.html">Staging buffer</a></li><li class='Nav__item Nav__item--active'><a href="../../en/Vertex_buffers/Index_buffer.html">Index buffer</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Uniform buffers</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Descriptor set layout and buffer</a></li><li class='Nav__item '><a href="../../en/Uniform_buffers/Descriptor_pool_and_sets.html">Descriptor pool and sets</a></li></ul></li><li class='Nav__item  has-children'><a href="../../en/Texture_mapping/Images.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Texture mapping</a><ul class='Nav'><li class='Nav__item '><a href="../../en/Texture_mapping/Images.html">Images</a></li><li class='Nav__item '><a href="../../en/Texture_mapping/Image_view_and_sampler.html">Image view and sampler</a></li><li class='Nav__item '><a href="../../en/Texture_mapping/Combined_image_sampler.html">Combined image sampler</a></li></ul></li><li class='Nav__item '><a href="../../en/Depth_buffering.html">Depth buffering</a></li><li class='Nav__item '><a href="../../en/Loading_models.html">Loading models</a></li><li class='Nav__item '><a href="../../en/Generating_Mipmaps.html">Generating Mipmaps</a></li><li class='Nav__item '><a href="../../en/Multisampling.html">Multisampling</a></li><li class='Nav__item '><a href="../../en/Compute_Shader.html">Compute Shader</a></li><li class='Nav__item '><a href="../../en/FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../../en/Privacy_policy.html">Privacy policy</a></li></ul>                </div>

                <div class="sidebar-links">
                    
                        <!-- Links -->
                        <a href="https://github.com/Overv/VulkanTutorial" target="_blank">GitHub Repository</a><br><a href="https://www.paypal.me/AOvervoorde" target="_blank">Support the website</a><br><br><a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/" target="_blank">Vulkan Specification</a><br><a href="https://lunarg.com/vulkan-sdk/" target="_blank">LunarG Vulkan SDK</a><br><a href="https://github.com/KhronosGroup/Vulkan-Guide" target="_blank">Vulkan Guide</a><br><a href="https://vulkan.gpuinfo.org/" target="_blank">Vulkan Hardware Database</a><br><br><a href="https://github.com/bwasty/vulkan-tutorial-rs" target="_blank">Rust code</a><br><a href="https://github.com/Naitsirc98/Vulkan-Tutorial-Java" target="_blank">Java code</a><br><a href="https://github.com/vkngwrapper/vulkan-tutorial" target="_blank">Go code</a><br><a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles" target="_blank">Visual Studio 2019 samples</a><br><a href="https://github.com/fangcun010/VulkanTutorialCN" target="_blank">Chinese translation</a><br>
                        <div id="toggleCodeBlock">
                                                </div>

                        <!-- Twitter -->
                                                            </div>

                <div style="color: #666; padding: 0 20px 0 20px; font-size: 90%">
                    This site is not affiliated with or endorsed by the Khronos Group. VulkanÂ® and the Vulkan logo are trademarks of the Khronos Group Inc.
                </div>
            </div>
        </div>
        <div class="right-column  content-area col-sm-9">
            <div class="content-page" style="position: relative;">
                <div class="adbox-side" style="position: absolute; left: calc(100% + 50px);">
                    <div id="waldo-tag-4310"></div>
                </div>

                <div class="adbox-side" style="position: absolute; left: -350px">
                    <div id="waldo-tag-4312"></div>
                </div>

                                    <div id="tipue_search_content" style="display:none"></div>
                
                <div class="doc_content">
                    <article>
            <div class="page-header">
            <h1>Index buffer</h1>
        </div>
    
    <ul class="TableOfContents">
<li>
<p><a href="#page_Introduction">Introduction</a></p>
</li>
<li>
<p><a href="#page_Index-buffer-creation">Index buffer creation</a></p>
</li>
<li>
<p><a href="#page_Using-an-index-buffer">Using an index buffer</a></p>
</li>
</ul>
<h2 id="page_Introduction">Introduction</h2>
<p>The 3D meshes you'll be rendering in a real world application will often share
vertices between multiple triangles. This already happens even with something
simple like drawing a rectangle:</p>
<p><img src="/images/vertex_vs_index.svg" alt="" /></p>
<p>Drawing a rectangle takes two triangles, which means that we need a vertex
buffer with 6 vertices. The problem is that the data of two vertices needs to be
duplicated resulting in 50% redundancy. It only gets worse with more complex
meshes, where vertices are reused in an average number of 3 triangles. The
solution to this problem is to use an <em>index buffer</em>.</p>
<p>An index buffer is essentially an array of pointers into the vertex buffer. It
allows you to reorder the vertex data, and reuse existing data for multiple
vertices. The illustration above demonstrates what the index buffer would look
like for the rectangle if we have a vertex buffer containing each of the four
unique vertices. The first three indices define the upper-right triangle and the
last three indices define the vertices for the bottom-left triangle.</p>
<h2 id="page_Index-buffer-creation">Index buffer creation</h2>
<p>In this chapter we're going to modify the vertex data and add index data to
draw a rectangle like the one in the illustration. Modify the vertex data to
represent the four corners:</p>
<pre><code class="language-c++">const std::vector&lt;Vertex&gt; vertices = {
    {{-0.5f, -0.5f}, {1.0f, 0.0f, 0.0f}},
    {{0.5f, -0.5f}, {0.0f, 1.0f, 0.0f}},
    {{0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}},
    {{-0.5f, 0.5f}, {1.0f, 1.0f, 1.0f}}
};
</code></pre>
<p>The top-left corner is red, top-right is green, bottom-right is blue and the
bottom-left is white. We'll add a new array <code>indices</code> to represent the contents
of the index buffer. It should match the indices in the illustration to draw the
upper-right triangle and bottom-left triangle.</p>
<pre><code class="language-c++">const std::vector&lt;uint16_t&gt; indices = {
    0, 1, 2, 2, 3, 0
};
</code></pre>
<p>It is possible to use either <code>uint16_t</code> or <code>uint32_t</code> for your index buffer
depending on the number of entries in <code>vertices</code>. We can stick to <code>uint16_t</code> for
now because we're using less than 65535 unique vertices.</p>
<p>Just like the vertex data, the indices need to be uploaded into a <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkBuffer.html"><code>VkBuffer</code></a> for
the GPU to be able to access them. Define two new class members to hold the
resources for the index buffer:</p>
<pre><code class="language-c++">VkBuffer vertexBuffer;
VkDeviceMemory vertexBufferMemory;
VkBuffer indexBuffer;
VkDeviceMemory indexBufferMemory;
</code></pre>
<p>The <code>createIndexBuffer</code> function that we'll add now is almost identical to
<code>createVertexBuffer</code>:</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    createVertexBuffer();
    createIndexBuffer();
    ...
}

void createIndexBuffer() {
    VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size();

    VkBuffer stagingBuffer;
    VkDeviceMemory stagingBufferMemory;
    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory);

    void* data;
    vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data);
    memcpy(data, indices.data(), (size_t) bufferSize);
    vkUnmapMemory(device, stagingBufferMemory);

    createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory);

    copyBuffer(stagingBuffer, indexBuffer, bufferSize);

    vkDestroyBuffer(device, stagingBuffer, nullptr);
    vkFreeMemory(device, stagingBufferMemory, nullptr);
}
</code></pre>
<p>There are only two notable differences. The <code>bufferSize</code> is now equal to the
number of indices times the size of the index type, either <code>uint16_t</code> or
<code>uint32_t</code>. The usage of the <code>indexBuffer</code> should be
<code>VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> instead of
<code>VK_BUFFER_USAGE_VERTEX_BUFFER_BIT</code>, which makes sense. Other than that, the
process is exactly the same. We create a staging buffer to copy the contents of
<code>indices</code> to and then copy it to the final device local index buffer.</p>
<p>The index buffer should be cleaned up at the end of the program, just like the
vertex buffer:</p>
<pre><code class="language-c++">void cleanup() {
    cleanupSwapChain();

    vkDestroyBuffer(device, indexBuffer, nullptr);
    vkFreeMemory(device, indexBufferMemory, nullptr);

    vkDestroyBuffer(device, vertexBuffer, nullptr);
    vkFreeMemory(device, vertexBufferMemory, nullptr);

    ...
}
</code></pre>
<h2 id="page_Using-an-index-buffer">Using an index buffer</h2>
<p>Using an index buffer for drawing involves two changes to
<code>recordCommandBuffer</code>. We first need to bind the index buffer, just like we did
for the vertex buffer. The difference is that you can only have a single index
buffer. It's unfortunately not possible to use different indices for each vertex
attribute, so we do still have to completely duplicate vertex data even if just
one attribute varies.</p>
<pre><code class="language-c++">vkCmdBindVertexBuffers(commandBuffer, 0, 1, vertexBuffers, offsets);

vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT16);
</code></pre>
<p>An index buffer is bound with <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindIndexBuffer.html"><code>vkCmdBindIndexBuffer</code></a> which has the index buffer,
a byte offset into it, and the type of index data as parameters. As mentioned
before, the possible types are <code>VK_INDEX_TYPE_UINT16</code> and
<code>VK_INDEX_TYPE_UINT32</code>.</p>
<p>Just binding an index buffer doesn't change anything yet, we also need to change
the drawing command to tell Vulkan to use the index buffer. Remove the
<a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a> line and replace it with <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdDrawIndexed.html"><code>vkCmdDrawIndexed</code></a>:</p>
<pre><code class="language-c++">vkCmdDrawIndexed(commandBuffer, static_cast&lt;uint32_t&gt;(indices.size()), 1, 0, 0, 0);
</code></pre>
<p>A call to this function is very similar to <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdDraw.html"><code>vkCmdDraw</code></a>. The first two parameters
specify the number of indices and the number of instances. We're not using
instancing, so just specify <code>1</code> instance. The number of indices represents the
number of vertices that will be passed to the vertex shader. The next parameter
specifies an offset into the index buffer, using a value of <code>1</code> would cause the
graphics card to start reading at the second index. The second to last parameter
specifies an offset to add to the indices in the index buffer. The final
parameter specifies an offset for instancing, which we're not using.</p>
<p>Now run your program and you should see the following:</p>
<p><img src="/images/indexed_rectangle.png" alt="" /></p>
<p>You now know how to save memory by reusing vertices with index buffers. This
will become especially important in a future chapter where we're going to load
complex 3D models.</p>
<p>The previous chapter already mentioned that you should allocate multiple
resources like buffers from a single memory allocation, but in fact you should
go a step further. <a href="https://developer.nvidia.com/vulkan-memory-management" class="Link--external">Driver developers recommend</a>
that you also store multiple buffers, like the vertex and index buffer, into a
single <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkBuffer.html"><code>VkBuffer</code></a> and use offsets in commands like <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindVertexBuffers.html"><code>vkCmdBindVertexBuffers</code></a>. The
advantage is that your data is more cache friendly in that case, because it's
closer together. It is even possible to reuse the same chunk of memory for
multiple resources if they are not used during the same render operations,
provided that their data is refreshed, of course. This is known as <em>aliasing</em>
and some Vulkan functions have explicit flags to specify that you want to do
this.</p>
<p><a href="../../code/21_index_buffer.cpp">C++ code</a> /
<a href="../../code/18_shader_vertexbuffer.vert">Vertex shader</a> /
<a href="../../code/18_shader_vertexbuffer.frag">Fragment shader</a></p>

        <nav>
        <ul class="pager">
            <li><a href="../../en/Vertex_buffers/Staging_buffer.html">Previous</a></li>            <li><a href="../../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Next</a></li>        </ul>
    </nav>
    
        <div id="waldo-tag-4314"></div>
    
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </article>

                </div>
            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../../themes/vulkan/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../../themes/vulkan/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../../themes/vulkan/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../../tipuesearch/tipuesearch_set.js"></script>
        <script type="text/javascript" src="../../tipuesearch/tipuesearch.min.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(document).ready(function() {
                $('#tipue_search_input').tipuesearch({
                    'show': 10,
                    'mode': 'json',
                    'base_url': '../../'
                });
            });
        </script>
    
</body>
</html>
