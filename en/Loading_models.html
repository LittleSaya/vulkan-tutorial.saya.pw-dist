<!DOCTYPE html>
<!--[if lt IE 7]>       <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>          <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>          <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->  <html class="no-js" lang="en"> <!--<![endif]-->
<head>
    <title>Loading models - Vulkan Tutorial</title>
    <meta name="description" content="A tutorial that teaches you everything it takes to render 3D graphics with the Vulkan API. It covers everything from Windows/Linux setup to rendering and debugging." />
    <meta name="author" content="Alexander Overvoorde">
    <meta charset="UTF-8">
    <link rel="icon" href="/images/favicon.png" type="image/png">
    <!-- Mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Font -->
    
    <!-- CSS -->
    <link href='../themes/vulkan/css/theme.min.css' rel='stylesheet' type='text/css'><link href='../themes/vulkan/css/theme-blue.min.css' rel='stylesheet' type='text/css'><link href='../themes/vulkan/css/css.css' rel='stylesheet' type='text/css'>
            <!-- Tipue Search -->
        <link href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body class="">
    
<div class="container-fluid fluid-height wrapper">
    <div class="row columns content">
        <div class="left-column article-tree col-sm-3 hidden-print">
            <!-- For Mobile -->
            <div class="responsive-collapse">
                <button type="button" class="btn btn-sidebar" id="menu-spinner-button">
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
            </div>
            <div id="sub-nav-collapse" class="sub-nav-collapse">
                <div class="nav-logo">
                    Vulkan Tutorial
                </div>

                <!-- Language picker -->
                <div class="language-picker">
                <a href="/Introduction">English</a>                </div>

                <!-- Navigation -->
                <div style="padding-top: 20px; padding-bottom: 20px; background: #272525">
                <ul class='Nav'><li class='Nav__item '><a href="../en/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../en/Overview.html">Overview</a></li><li class='Nav__item '><a href="../en/Development_environment.html">Development environment</a></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing a triangle</a><ul class='Nav'><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Setup/Base_code.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Setup</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Base_code.html">Base code</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Instance.html">Instance</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Validation_layers.html">Validation layers</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families.html">Physical devices and queue families</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Setup/Logical_device_and_queues.html">Logical device and queues</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Presentation/Window_surface.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Presentation</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Presentation/Window_surface.html">Window surface</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Presentation/Swap_chain.html">Swap chain</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Presentation/Image_views.html">Image views</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Graphics pipeline basics</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Introduction.html">Introduction</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules.html">Shader modules</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Fixed_functions.html">Fixed functions</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Render_passes.html">Render passes</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Graphics_pipeline_basics/Conclusion.html">Conclusion</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Drawing_a_triangle/Drawing/Framebuffers.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Drawing</a><ul class='Nav'><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Framebuffers.html">Framebuffers</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Command_buffers.html">Command buffers</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Rendering_and_presentation.html">Rendering and presentation</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/X_Object_relationships.html">X Object relationships</a></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Drawing/Frames_in_flight.html">Frames in flight</a></li></ul></li><li class='Nav__item '><a href="../en/Drawing_a_triangle/Swap_chain_recreation.html">Swap chain recreation</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Vertex_buffers/Vertex_input_description.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Vertex buffers</a><ul class='Nav'><li class='Nav__item '><a href="../en/Vertex_buffers/Vertex_input_description.html">Vertex input description</a></li><li class='Nav__item '><a href="../en/Vertex_buffers/Vertex_buffer_creation.html">Vertex buffer creation</a></li><li class='Nav__item '><a href="../en/Vertex_buffers/Staging_buffer.html">Staging buffer</a></li><li class='Nav__item '><a href="../en/Vertex_buffers/Index_buffer.html">Index buffer</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Uniform buffers</a><ul class='Nav'><li class='Nav__item '><a href="../en/Uniform_buffers/Descriptor_set_layout_and_buffer.html">Descriptor set layout and buffer</a></li><li class='Nav__item '><a href="../en/Uniform_buffers/Descriptor_pool_and_sets.html">Descriptor pool and sets</a></li></ul></li><li class='Nav__item  has-children'><a href="../en/Texture_mapping/Images.html" class="folder"><i class="Nav__arrow">&nbsp;</i>Texture mapping</a><ul class='Nav'><li class='Nav__item '><a href="../en/Texture_mapping/Images.html">Images</a></li><li class='Nav__item '><a href="../en/Texture_mapping/Image_view_and_sampler.html">Image view and sampler</a></li><li class='Nav__item '><a href="../en/Texture_mapping/Combined_image_sampler.html">Combined image sampler</a></li></ul></li><li class='Nav__item '><a href="../en/Depth_buffering.html">Depth buffering</a></li><li class='Nav__item Nav__item--active'><a href="../en/Loading_models.html">Loading models</a></li><li class='Nav__item '><a href="../en/Generating_Mipmaps.html">Generating Mipmaps</a></li><li class='Nav__item '><a href="../en/Multisampling.html">Multisampling</a></li><li class='Nav__item '><a href="../en/Compute_Shader.html">Compute Shader</a></li><li class='Nav__item '><a href="../en/FAQ.html">FAQ</a></li><li class='Nav__item '><a href="../en/Privacy_policy.html">Privacy policy</a></li></ul>                </div>

                <div class="sidebar-links">
                    
                        <!-- Links -->
                        <a href="https://github.com/Overv/VulkanTutorial" target="_blank">GitHub Repository</a><br><a href="https://www.paypal.me/AOvervoorde" target="_blank">Support the website</a><br><br><a href="https://www.khronos.org/registry/vulkan/specs/1.3-extensions/html/" target="_blank">Vulkan Specification</a><br><a href="https://lunarg.com/vulkan-sdk/" target="_blank">LunarG Vulkan SDK</a><br><a href="https://github.com/KhronosGroup/Vulkan-Guide" target="_blank">Vulkan Guide</a><br><a href="https://vulkan.gpuinfo.org/" target="_blank">Vulkan Hardware Database</a><br><br><a href="https://github.com/bwasty/vulkan-tutorial-rs" target="_blank">Rust code</a><br><a href="https://github.com/Naitsirc98/Vulkan-Tutorial-Java" target="_blank">Java code</a><br><a href="https://github.com/vkngwrapper/vulkan-tutorial" target="_blank">Go code</a><br><a href="https://github.com/jjYBdx4IL/VulkanTutorial-VisualStudioProjectFiles" target="_blank">Visual Studio 2019 samples</a><br><a href="https://github.com/fangcun010/VulkanTutorialCN" target="_blank">Chinese translation</a><br>
                        <div id="toggleCodeBlock">
                                                </div>

                        <!-- Twitter -->
                                                            </div>

                <div style="color: #666; padding: 0 20px 0 20px; font-size: 90%">
                    This site is not affiliated with or endorsed by the Khronos Group. VulkanÂ® and the Vulkan logo are trademarks of the Khronos Group Inc.
                </div>
            </div>
        </div>
        <div class="right-column  content-area col-sm-9">
            <div class="content-page" style="position: relative;">
                <div class="adbox-side" style="position: absolute; left: calc(100% + 50px);">
                    <div id="waldo-tag-4310"></div>
                </div>

                <div class="adbox-side" style="position: absolute; left: -350px">
                    <div id="waldo-tag-4312"></div>
                </div>

                                    <div id="tipue_search_content" style="display:none"></div>
                
                <div class="doc_content">
                    <article>
            <div class="page-header">
            <h1>Loading models</h1>
        </div>
    
    <ul class="TableOfContents">
<li>
<p><a href="#page_Introduction">Introduction</a></p>
</li>
<li>
<p><a href="#page_Library">Library</a></p>
</li>
<li>
<p><a href="#page_Sample-mesh">Sample mesh</a></p>
</li>
<li>
<p><a href="#page_Loading-vertices-and-indices">Loading vertices and indices</a></p>
</li>
<li>
<p><a href="#page_Vertex-deduplication">Vertex deduplication</a></p>
</li>
</ul>
<h2 id="page_Introduction">Introduction</h2>
<p>Your program is now ready to render textured 3D meshes, but the current geometry
in the <code>vertices</code> and <code>indices</code> arrays is not very interesting yet. In this
chapter we're going to extend the program to load the vertices and indices from
an actual model file to make the graphics card actually do some work.</p>
<p>Many graphics API tutorials have the reader write their own OBJ loader in a
chapter like this. The problem with this is that any remotely interesting 3D
application will soon require features that are not supported by this file
format, like skeletal animation. We <em>will</em> load mesh data from an OBJ model in
this chapter, but we'll focus more on integrating the mesh data with the program
itself rather than the details of loading it from a file.</p>
<h2 id="page_Library">Library</h2>
<p>We will use the <a href="https://github.com/syoyo/tinyobjloader" class="Link--external">tinyobjloader</a> library
to load vertices and faces from an OBJ file. It's fast and it's easy to
integrate because it's a single file library like stb_image. Go to the
repository linked above and download the <code>tiny_obj_loader.h</code> file to a folder in
your library directory.</p>
<p><strong>Visual Studio</strong></p>
<p>Add the directory with <code>tiny_obj_loader.h</code> in it to the <code>Additional Include Directories</code> paths.</p>
<p><img src="/images/include_dirs_tinyobjloader.png" alt="" /></p>
<p><strong>Makefile</strong></p>
<p>Add the directory with <code>tiny_obj_loader.h</code> to the include directories for GCC:</p>
<pre><code class="language-text">VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/x86_64
STB_INCLUDE_PATH = /home/user/libraries/stb
TINYOBJ_INCLUDE_PATH = /home/user/libraries/tinyobjloader

...

CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/include -I$(STB_INCLUDE_PATH) -I$(TINYOBJ_INCLUDE_PATH)
</code></pre>
<h2 id="page_Sample-mesh">Sample mesh</h2>
<p>In this chapter we won't be enabling lighting yet, so it helps to use a sample
model that has lighting baked into the texture. An easy way to find such models
is to look for 3D scans on <a href="https://sketchfab.com/" class="Link--external">Sketchfab</a>. Many of the
models on that site are available in OBJ format with a permissive license.</p>
<p>For this tutorial I've decided to go with the <a href="https://sketchfab.com/3d-models/viking-room-a49f1b8e4f5c4ecf9e1fe7d81915ad38" class="Link--external">Viking room</a>
model by <a href="https://sketchfab.com/nigelgoh" class="Link--external">nigelgoh</a> (<a href="https://web.archive.org/web/20200428202538/https://sketchfab.com/3d-models/viking-room-a49f1b8e4f5c4ecf9e1fe7d81915ad38" class="Link--external">CC BY 4.0</a>). I tweaked the size and orientation of the model to use it
as a drop in replacement for the current geometry:</p>
<ul>
<li>
<a href="../resources/viking_room.obj">viking_room.obj</a>
</li>
<li>
<a href="../resources/viking_room.png">viking_room.png</a>
</li>
</ul>
<p>Feel free to use your own model, but make sure that it only consists of one
material and that is has dimensions of about 1.5 x 1.5 x 1.5 units. If it is
larger than that, then you'll have to change the view matrix. Put the model file
in a new <code>models</code> directory next to <code>shaders</code> and <code>textures</code>, and put the
texture image in the <code>textures</code> directory.</p>
<p>Put two new configuration variables in your program to define the model and
texture paths:</p>
<pre><code class="language-c++">const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;

const std::string MODEL_PATH = &quot;models/viking_room.obj&quot;;
const std::string TEXTURE_PATH = &quot;textures/viking_room.png&quot;;
</code></pre>
<p>And update <code>createTextureImage</code> to use this path variable:</p>
<pre><code class="language-c++">stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);
</code></pre>
<h2 id="page_Loading-vertices-and-indices">Loading vertices and indices</h2>
<p>We're going to load the vertices and indices from the model file now, so you
should remove the global <code>vertices</code> and <code>indices</code> arrays now. Replace them with
non-const containers as class members:</p>
<pre><code class="language-c++">std::vector&lt;Vertex&gt; vertices;
std::vector&lt;uint32_t&gt; indices;
VkBuffer vertexBuffer;
VkDeviceMemory vertexBufferMemory;
</code></pre>
<p>You should change the type of the indices from <code>uint16_t</code> to <code>uint32_t</code>, because
there are going to be a lot more vertices than 65535. Remember to also change
the <a href="https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkCmdBindIndexBuffer.html"><code>vkCmdBindIndexBuffer</code></a> parameter:</p>
<pre><code class="language-c++">vkCmdBindIndexBuffer(commandBuffer, indexBuffer, 0, VK_INDEX_TYPE_UINT32);
</code></pre>
<p>The tinyobjloader library is included in the same way as STB libraries. Include
the <code>tiny_obj_loader.h</code> file and make sure to define
<code>TINYOBJLOADER_IMPLEMENTATION</code> in one source file to include the function
bodies and avoid linker errors:</p>
<pre><code class="language-c++">#define TINYOBJLOADER_IMPLEMENTATION
#include &lt;tiny_obj_loader.h&gt;
</code></pre>
<p>We're now going to write a <code>loadModel</code> function that uses this library to
populate the <code>vertices</code> and <code>indices</code> containers with the vertex data from the
mesh. It should be called somewhere before the vertex and index buffers are
created:</p>
<pre><code class="language-c++">void initVulkan() {
    ...
    loadModel();
    createVertexBuffer();
    createIndexBuffer();
    ...
}

...

void loadModel() {

}
</code></pre>
<p>A model is loaded into the library's data structures by calling the
<code>tinyobj::LoadObj</code> function:</p>
<pre><code class="language-c++">void loadModel() {
    tinyobj::attrib_t attrib;
    std::vector&lt;tinyobj::shape_t&gt; shapes;
    std::vector&lt;tinyobj::material_t&gt; materials;
    std::string warn, err;

    if (!tinyobj::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.c_str())) {
        throw std::runtime_error(warn + err);
    }
}
</code></pre>
<p>An OBJ file consists of positions, normals, texture coordinates and faces. Faces
consist of an arbitrary amount of vertices, where each vertex refers to a
position, normal and/or texture coordinate by index. This makes it possible to
not just reuse entire vertices, but also individual attributes.</p>
<p>The <code>attrib</code> container holds all of the positions, normals and texture
coordinates in its <code>attrib.vertices</code>, <code>attrib.normals</code> and <code>attrib.texcoords</code>
vectors. The <code>shapes</code> container contains all of the separate objects and their
faces. Each face consists of an array of vertices, and each vertex contains the
indices of the position, normal and texture coordinate attributes. OBJ models
can also define a material and texture per face, but we will be ignoring those.</p>
<p>The <code>err</code> string contains errors and the <code>warn</code> string contains warnings that occurred while loading the
file, like a missing material definition. Loading only really failed if the
<code>LoadObj</code> function returns <code>false</code>. As mentioned above, faces in OBJ files can
actually contain an arbitrary number of vertices, whereas our application can
only render triangles. Luckily the <code>LoadObj</code> has an optional parameter to
automatically triangulate such faces, which is enabled by default.</p>
<p>We're going to combine all of the faces in the file into a single model, so just
iterate over all of the shapes:</p>
<pre><code class="language-c++">for (const auto&amp; shape : shapes) {

}
</code></pre>
<p>The triangulation feature has already made sure that there are three vertices
per face, so we can now directly iterate over the vertices and dump them
straight into our <code>vertices</code> vector:</p>
<pre><code class="language-c++">for (const auto&amp; shape : shapes) {
    for (const auto&amp; index : shape.mesh.indices) {
        Vertex vertex{};

        vertices.push_back(vertex);
        indices.push_back(indices.size());
    }
}
</code></pre>
<p>For simplicity, we will assume that every vertex is unique for now, hence the
simple auto-increment indices. The <code>index</code> variable is of type
<code>tinyobj::index_t</code>, which contains the <code>vertex_index</code>, <code>normal_index</code> and
<code>texcoord_index</code> members. We need to use these indices to look up the actual
vertex attributes in the <code>attrib</code> arrays:</p>
<pre><code class="language-c++">vertex.pos = {
    attrib.vertices[3 * index.vertex_index + 0],
    attrib.vertices[3 * index.vertex_index + 1],
    attrib.vertices[3 * index.vertex_index + 2]
};

vertex.texCoord = {
    attrib.texcoords[2 * index.texcoord_index + 0],
    attrib.texcoords[2 * index.texcoord_index + 1]
};

vertex.color = {1.0f, 1.0f, 1.0f};
</code></pre>
<p>Unfortunately the <code>attrib.vertices</code> array is an array of <code>float</code> values instead
of something like <code>glm::vec3</code>, so you need to multiply the index by <code>3</code>.
Similarly, there are two texture coordinate components per entry. The offsets of
<code>0</code>, <code>1</code> and <code>2</code> are used to access the X, Y and Z components, or the U and V
components in the case of texture coordinates.</p>
<p>Run your program now with optimization enabled (e.g. <code>Release</code> mode in Visual
Studio and with the <code>-O3</code> compiler flag for GCC`). This is necessary, because
otherwise loading the model will be very slow. You should see something like the
following:</p>
<p><img src="/images/inverted_texture_coordinates.png" alt="" /></p>
<p>Great, the geometry looks correct, but what's going on with the texture? The OBJ format assumes a coordinate system where a vertical coordinate of <code>0</code> means the bottom of the image, however we've uploaded our image into Vulkan in a top to bottom orientation where <code>0</code> means the top of the image. Solve this by
flipping the vertical component of the texture coordinates:</p>
<pre><code class="language-c++">vertex.texCoord = {
    attrib.texcoords[2 * index.texcoord_index + 0],
    1.0f - attrib.texcoords[2 * index.texcoord_index + 1]
};
</code></pre>
<p>When you run your program again, you should now see the correct result:</p>
<p><img src="/images/drawing_model.png" alt="" /></p>
<p>All that hard work is finally beginning to pay off with a demo like this!</p>
<blockquote>
<p>As the model rotates you may notice that the rear (backside of the walls) looks a bit funny. This is normal and is simply because the model is not really designed to be viewed from that side.</p>
</blockquote>
<h2 id="page_Vertex-deduplication">Vertex deduplication</h2>
<p>Unfortunately we're not really taking advantage of the index buffer yet. The
<code>vertices</code> vector contains a lot of duplicated vertex data, because many
vertices are included in multiple triangles. We should keep only the unique
vertices and use the index buffer to reuse them whenever they come up. A
straightforward way to implement this is to use a <code>map</code> or <code>unordered_map</code> to
keep track of the unique vertices and respective indices:</p>
<pre><code class="language-c++">#include &lt;unordered_map&gt;

...

std::unordered_map&lt;Vertex, uint32_t&gt; uniqueVertices{};

for (const auto&amp; shape : shapes) {
    for (const auto&amp; index : shape.mesh.indices) {
        Vertex vertex{};

        ...

        if (uniqueVertices.count(vertex) == 0) {
            uniqueVertices[vertex] = static_cast&lt;uint32_t&gt;(vertices.size());
            vertices.push_back(vertex);
        }

        indices.push_back(uniqueVertices[vertex]);
    }
}
</code></pre>
<p>Every time we read a vertex from the OBJ file, we check if we've already seen a
vertex with the exact same position and texture coordinates before. If not, we
add it to <code>vertices</code> and store its index in the <code>uniqueVertices</code> container.
After that we add the index of the new vertex to <code>indices</code>. If we've seen the
exact same vertex before, then we look up its index in <code>uniqueVertices</code> and
store that index in <code>indices</code>.</p>
<p>The program will fail to compile right now, because using a user-defined type
like our <code>Vertex</code> struct as key in a hash table requires us to implement two
functions: equality test and hash calculation. The former is easy to implement
by overriding the <code>==</code> operator in the <code>Vertex</code> struct:</p>
<pre><code class="language-c++">bool operator==(const Vertex&amp; other) const {
    return pos == other.pos &amp;&amp; color == other.color &amp;&amp; texCoord == other.texCoord;
}
</code></pre>
<p>A hash function for <code>Vertex</code> is implemented by specifying a template
specialization for <code>std::hash&lt;T&gt;</code>. Hash functions are a complex topic, but
<a href="http://en.cppreference.com/w/cpp/utility/hash" class="Link--external">cppreference.com recommends</a> the
following approach combining the fields of a struct to create a decent quality
hash function:</p>
<pre><code class="language-c++">namespace std {
    template&lt;&gt; struct hash&lt;Vertex&gt; {
        size_t operator()(Vertex const&amp; vertex) const {
            return ((hash&lt;glm::vec3&gt;()(vertex.pos) ^
                   (hash&lt;glm::vec3&gt;()(vertex.color) &lt;&lt; 1)) &gt;&gt; 1) ^
                   (hash&lt;glm::vec2&gt;()(vertex.texCoord) &lt;&lt; 1);
        }
    };
}
</code></pre>
<p>This code should be placed outside the <code>Vertex</code> struct. The hash functions for
the GLM types need to be included using the following header:</p>
<pre><code class="language-c++">#define GLM_ENABLE_EXPERIMENTAL
#include &lt;glm/gtx/hash.hpp&gt;
</code></pre>
<p>The hash functions are defined in the <code>gtx</code> folder, which means that it is
technically still an experimental extension to GLM. Therefore you need to define
<code>GLM_ENABLE_EXPERIMENTAL</code> to use it. It means that the API could change with a
new version of GLM in the future, but in practice the API is very stable.</p>
<p>You should now be able to successfully compile and run your program. If you
check the size of <code>vertices</code>, then you'll see that it has shrunk down from
1,500,000 to 265,645! That means that each vertex is reused in an average number
of ~6 triangles. This definitely saves us a lot of GPU memory.</p>
<p><a href="../code/28_model_loading.cpp">C++ code</a> /
<a href="../code/27_shader_depth.vert">Vertex shader</a> /
<a href="../code/27_shader_depth.frag">Fragment shader</a></p>

        <nav>
        <ul class="pager">
            <li><a href="../en/Depth_buffering.html">Previous</a></li>            <li><a href="../en/Generating_Mipmaps.html">Next</a></li>        </ul>
    </nav>
    
        <div id="waldo-tag-4314"></div>
    
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </article>

                </div>
            </div>
        </div>
    </div>
</div>

    
    <!-- jQuery -->
    <script src="../themes/vulkan/js/jquery-1.11.3.min.js"></script>

    <!-- hightlight.js -->
    <script src="../themes/vulkan/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- JS -->
    
    <script src="../themes/vulkan/js/daux.js"></script>

            <!-- Tipue Search -->
        <script type="text/javascript" src="../tipuesearch/tipuesearch_set.js"></script>
        <script type="text/javascript" src="../tipuesearch/tipuesearch.min.js"></script>

        <script>
            window.onunload = function(){}; // force $(document).ready to be called on back/forward navigation in firefox
            $(document).ready(function() {
                $('#tipue_search_input').tipuesearch({
                    'show': 10,
                    'mode': 'json',
                    'base_url': '../'
                });
            });
        </script>
    
</body>
</html>
